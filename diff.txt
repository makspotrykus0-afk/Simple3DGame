diff --git a/game/Settler.cpp b/game/Settler.cpp
index 6d89abe..812ad02 100644
--- a/game/Settler.cpp
+++ b/game/Settler.cpp
@@ -1,960 +1,2198 @@
+
+#include <memory>
+
+#include <vector>
+
+#include <algorithm>
+
+#include <string>
+
+#include <iostream>
+#include <cmath>
 #include "Settler.h"
+
 #include "Tree.h"
+
 #include "BuildingInstance.h"
+
 #include "Colony.h"
+
 #include "Bed.h"
+
+#include "ResourceNode.h"
+
+#include "GatheringTask.h"
+
+#include "NavigationGrid.h"
+
+#include "Animal.h"
+
+#include "BuildingTask.h"
+
+#include "Item.h"
 #include "../core/GameEngine.h"
-#include "../core/GameSystem.h" // Added for GameSystem::getNavigationGrid
+
+#include "../core/GameSystem.h"
+
 #include "../systems/BuildingSystem.h"
+
 #include "../systems/StorageSystem.h"
+
+#include "../systems/SkillTypes.h"
+
+#include "../systems/CraftingSystem.h"
 #include "../components/EnergyComponent.h"
-#include "raymath.h"
-#include "NavigationGrid.h"
-#include <iostream>
-#include <algorithm>
-#include <string>
 
-// Externs or access to systems
-extern BuildingSystem* g_buildingSystem; 
-// extern NavigationGrid* g_navigationGrid; // REMOVED: Using GameSystem::getNavigationGrid()
+#include "../components/SkillsComponent.h"
+
+#include "../components/StatsComponent.h"
 
+#include "../components/PositionComponent.h"
+
+#include "../components/InventoryComponent.h"
+#include "raymath.h"
+extern BuildingSystem* g_buildingSystem;
 Settler::Settler(const std::string& name, const Vector3& pos, SettlerProfession profession)
-    : GameEntity(name), m_name(name), m_profession(profession), m_state(SettlerState::IDLE),
-      m_inventory(name, 50.0f), // Capacity 50
-      m_stats(name, 100.0f, 100.0f, 100.0f, 100.0f),
-      m_targetPosition(pos), m_moveSpeed(5.0f), m_rotation(0.0f),
-      m_currentBuildTask(nullptr), m_currentGatherTask(nullptr), m_targetStorage(nullptr),
-      m_gatherTimer(0.0f), m_gatherInterval(1.0f), m_isSelected(false) {
-    
-    position = pos;
-    
-    // Components
-    addComponent(std::make_shared<PositionComponent>(position));
-    // Add EnergyComponent with defaults
-    addComponent(std::make_shared<EnergyComponent>());
 
-    // We could add inventory component to entity, but we have it as member.
-    // Ideally it should be a component in the list.
-    
-    // Start with some skills
-    m_skills.addSkillXP(SkillType::BUILDING, 0.0f);
-    m_skills.addSkillXP(SkillType::WOODCUTTING, 0);
-}
+: GameEntity(name), m_name(name), m_profession(profession), m_state(SettlerState::IDLE),
 
-Settler::~Settler() {
-    if (m_currentGatherTask) delete m_currentGatherTask;
-}
+m_inventory(name, 50.0f),
 
-void Settler::render() {
-    // Simple capsule/cylinder render
-    Vector3 pos = position;
-    pos.y += 1.0f; // Center
-    
-    Color color = BLUE;
-    if (m_isSelected) color = GREEN;
-    if (m_profession == SettlerProfession::BUILDER) color = YELLOW;
-    if (m_profession == SettlerProfession::GATHERER) color = BROWN;
-    
-    DrawCapsule(Vector3{pos.x, pos.y - 0.8f, pos.z}, Vector3{pos.x, pos.y + 0.8f, pos.z}, 0.4f, 8, 8, color);
-    
-    // Draw face/direction
-    Vector3 forward = { 0, 0, 1 };
-    forward = Vector3RotateByAxisAngle(forward, {0, 1, 0}, m_rotation * DEG2RAD);
-    Vector3 facePos = Vector3Add(pos, Vector3Scale(forward, 0.4f));
-    facePos.y += 0.5f;
-    DrawSphere(facePos, 0.1f, WHITE);
-    
-    // State text above head
-    Vector3 textPos = pos;
-    textPos.y += 1.5f;
-    
-    // Helper to draw 3D text (using default raylib 2D in 3D context or billboard)
-    // For now, assume 2D overlay in main loop or skip specific text here
+m_stats(name, 100.0f, 100.0f, 100.0f, 100.0f),
+
+m_targetPosition(pos), m_moveSpeed(5.0f), m_rotation(0.0f),
+
+m_currentBuildTask(nullptr), m_currentGatherTask(nullptr), m_targetStorage(nullptr), m_targetWorkshop(nullptr),
+
+m_gatherTimer(0.0f), m_gatherInterval(1.0f), m_isSelected(false),
+
+m_currentGatherBush(nullptr), m_currentTree(nullptr), m_assignedBed(nullptr), m_targetFoodBush(nullptr),
+
+m_eatingTimer(0.0f), m_craftingTimer(0.0f), m_currentPathIndex(0),
+
+m_isMovingToCriticalTarget(false), m_pendingReevaluation(false) {
+
+position = pos;
+addComponent(std::make_shared<PositionComponent>(position));
+addComponent(std::make_shared<EnergyComponent>());
+
+m_skills.addSkill(SkillType::WOODCUTTING, 1);
+m_skills.addSkill(SkillType::MINING, 1);
+m_skills.addSkill(SkillType::BUILDING, 1);
+m_skills.addSkill(SkillType::FARMING, 1);
+
+m_prevGatherWood = gatherWood;
+m_prevGatherStone = gatherStone;
+m_prevGatherFood = gatherFood;
+m_prevPerformBuilding = performBuilding;
+m_prevHuntAnimals = huntAnimals;
+m_prevCraftItems = craftItems;
+m_prevHaulToStorage = haulToStorage;
+m_prevTendCrops = tendCrops;
 
-}
 
-InteractionResult Settler::interact(GameEntity* player) {
-    (void)player;
-    return { true, "Hello, I am " + m_name + "." };
 }
+Settler::~Settler() {
+
+if (m_currentGatherTask) delete m_currentGatherTask;
 
-InteractionInfo Settler::getDisplayInfo() const {
-    InteractionInfo info;
-    info.objectName = m_name;
-    info.objectDescription = "A settler of the colony.";
-    info.availableActions.push_back(GetStateString());
-    return info;
 }
+void Settler::Update(float deltaTime,
 
-std::string Settler::GetStateString() const {
-    switch (m_state) {
-        case SettlerState::IDLE: return "Idle";
-        case SettlerState::MOVING: return "Moving";
-        case SettlerState::GATHERING: return "Gathering";
-        case SettlerState::BUILDING: return "Building";
-        case SettlerState::SLEEPING: return "Sleeping";
-        case SettlerState::HUNTING: return "Hunting";
-        case SettlerState::HAULING: return "Hauling";
-        case SettlerState::MOVING_TO_STORAGE: return "Moving to Storage";
-        case SettlerState::DEPOSITING: return "Depositing";
-        case SettlerState::SEARCHING_FOR_FOOD: return "Searching for Food";
-        case SettlerState::MOVING_TO_FOOD: return "Moving to Food";
-        case SettlerState::EATING: return "Eating";
-        case SettlerState::MOVING_TO_BED: return "Moving to Bed";
-        default: return "Unknown";
+const std::vector<std::unique_ptr<Tree>>& trees,
+
+std::vector<WorldItem>& worldItems,
+
+const std::vector<Bush*>& bushes,
+
+const std::vector<BuildingInstance*>& buildings,
+
+const std::vector<std::unique_ptr<Animal>>& animals,
+
+const std::vector<std::unique_ptr<ResourceNode>>& resourceNodes) {
+
+(void)animals;
+
+(void)bushes;
+
+m_stats.update(deltaTime);
+
+if (CheckForJobFlagActivation()) {
+    if (IsStateInterruptible()) {
+        InterruptCurrentAction();
+    } else {
+        m_pendingReevaluation = true;
     }
 }
 
-void Settler::Update(float deltaTime, const std::vector<std::unique_ptr<Tree>>& trees, std::vector<WorldItem>& worldItems, const std::vector<Bush*>& bushes, const std::vector<BuildingInstance*>& buildings, const std::vector<std::unique_ptr<Animal>>& animals) {
-    // Suppress unused warnings
-    (void)worldItems;
-    (void)bushes;
-    (void)animals;
+bool isCriticalTask = (m_state == SettlerState::EATING) ||
+                      (m_state == SettlerState::SLEEPING) ||
+                      (m_state == SettlerState::SEARCHING_FOR_FOOD) ||
+                      (m_state == SettlerState::MOVING_TO_BED) ||
+                      (m_state == SettlerState::MOVING_TO_FOOD);
 
-    // Update stats
-    m_stats.update(deltaTime);
-    
-    // Hunger check
-    bool isCriticalTask = (m_state == SettlerState::EATING) ||
-                          (m_state == SettlerState::SLEEPING) || // Don't interrupt sleep? Maybe if starving.
-                          (m_state == SettlerState::SEARCHING_FOR_FOOD) ||
-                          (m_state == SettlerState::MOVING_TO_BED) ||
-                          (m_state == SettlerState::MOVING_TO_FOOD);
-
-    // Energy check
-    if (!isCriticalTask && m_stats.isExhausted()) {
-         if (m_assignedBed) {
-             m_state = SettlerState::MOVING_TO_BED;
-             MoveTo(m_assignedBed->getPosition());
-             // MoveTo sets state to MOVING, force it back to MOVING_TO_BED so we track context
-             m_state = SettlerState::MOVING_TO_BED;
-         } else {
-             m_state = SettlerState::SLEEPING;
-         }
+if (!isCriticalTask && m_stats.isExhausted()) {
+    if (m_assignedBed) {
+        m_state = SettlerState::MOVING_TO_BED;
+        m_isMovingToCriticalTarget = true;
+        MoveTo(m_assignedBed->getPosition());
+    } else {
+        m_state = SettlerState::SLEEPING;
     }
+}
 
-    if (!isCriticalTask && m_state != SettlerState::SLEEPING && m_state != SettlerState::MOVING_TO_BED && m_stats.getCurrentHunger() < m_stats.getFoodSearchThreshold()) {
-         // Trigger food search
-         // Optional: Only search if not already carrying something crucial or in combat
-         // For now, immediate override
-         m_state = SettlerState::SEARCHING_FOR_FOOD;
-         m_currentPath.clear(); // Stop current movement
-    }
+if (!isCriticalTask && m_state != SettlerState::SLEEPING && m_state != SettlerState::MOVING_TO_BED && m_stats.getCurrentHunger() < m_stats.getFoodSearchThreshold()) {
+    m_state = SettlerState::SEARCHING_FOR_FOOD;
+    m_isMovingToCriticalTarget = true;
+    m_currentPath.clear();
+}
 
-    // State Machine
-    static SettlerState lastState = m_state;
-    if (m_state != lastState) {
-        std::cout << "Settler " << m_name << " STATE CHANGE: "
-                  << (int)lastState << " -> " << (int)m_state << std::endl;
-        lastState = m_state;
-    }
+switch (m_state) {
+    case SettlerState::SEARCHING_FOR_FOOD:
+        UpdateSearchingForFood(deltaTime, bushes);
+        break;
+    case SettlerState::MOVING_TO_FOOD:
+        UpdateMovingToFood(deltaTime);
+        break;
+    case SettlerState::EATING:
+        UpdateEating(deltaTime);
+        break;
+    case SettlerState::GATHERING:
+        UpdateGathering(deltaTime, worldItems, buildings);
+        break;
+    case SettlerState::CHOPPING:
+        UpdateChopping(deltaTime);
+        break;
+    case SettlerState::MINING:
+        UpdateMining(deltaTime);
+        break;
+    case SettlerState::MOVING_TO_BED:
+        UpdateMovingToBed(deltaTime);
+        break;
+    case SettlerState::IDLE:
+        ExecuteNextAction();
+        if (m_state == SettlerState::IDLE) {
+            // Determine if we have resources
+            bool hasResources = false;
+            const auto& items = m_inventory.getItems();
+            for(const auto& item : items) {
+                if (item && item->item && item->item->getItemType() == ItemType::RESOURCE) {
+                    hasResources = true;
+                    break;
+                }
+            }
+
+                    // 1. PRIORYTET: Jeśli mamy JAKIEKOLWIEK zasoby i mamy je nosić, natychmiast idź do magazynu
+                    if (haulToStorage && hasResources) {
+                        BuildingInstance* storage = FindNearestStorage(buildings);
+                        if (storage) {
+                            m_targetStorage = storage;
+                            MoveTo(storage->getPosition());
+                            m_state = SettlerState::MOVING_TO_STORAGE;
+                            m_isMovingToCriticalTarget = false;
+                            break;
+                        } else {
+                            // Awaryjny fallback: upuść zasoby na ziemię
+                            std::cout << "[Settler] FALLBACK DROP: Brak dostępnych magazynów, upuszczam zasoby na ziemię." << std::endl;
+                            const auto& invItems = m_inventory.getItems();
+                            for (size_t i = 0; i < invItems.size(); ++i) {
+                                const auto& invItem = invItems[i];
+                                if (!invItem || !invItem->item || invItem->item->getItemType() != ItemType::RESOURCE) continue;
+                                ResourceItem* resItem = dynamic_cast<ResourceItem*>(invItem->item.get());
+                                if (!resItem) continue;
+                                // Stwórz kopię przedmiotu dla każdej jednostki
+                                for (int q = 0; q < invItem->quantity; ++q) {
+                                    auto droppedItem = std::make_unique<ResourceItem>(resItem->getResourceType(), resItem->getDisplayName(), resItem->getDescription());
+                                    // Upuść na ziemię w pobliżu settlera
+                                    if (GameEngine::dropItemCallback) {
+                                        Vector3 dropPos = position;
+                                        dropPos.x += (float)(rand()%10 - 5) * 0.1f;
+                                        dropPos.z += (float)(rand()%10 - 5) * 0.1f;
+                                        dropPos.y = 0.5f;
+                                        GameEngine::dropItemCallback(dropPos, droppedItem.release());
+                                    }
+                                }
+                            }
+                            // Wyczyść inventory z zasobów
+                            m_inventory.clear(); // lub iteracyjnie usuń, ale clear jest prostsze
+                            // Pozostajemy w IDLE
+                        }
+                    }
+
+            // 2. Jeśli nie mamy zasobów (lub nie znaleziono magazynu), szukaj itemów do podniesienia
+            if (m_state == SettlerState::IDLE && haulToStorage && !m_inventory.isFull()) {
+                UpdateHauling(deltaTime, buildings, worldItems);
+                if (m_state != SettlerState::IDLE) break;
+            }
+        }
+
+        if (m_state == SettlerState::IDLE) {
+            auto skills = m_skills.getAllSkills();
+            std::vector<Skill> sortedSkills;
+            for (const auto& pair : skills) {
+                sortedSkills.push_back(pair.second);
+            }
+            std::sort(sortedSkills.begin(), sortedSkills.end(), [](const Skill& a, const Skill& b) {
+                return a.priority > b.priority;
+            });
 
-    switch (m_state) {
-        case SettlerState::SEARCHING_FOR_FOOD:
-            UpdateSearchingForFood(deltaTime, bushes);
-            break;
-        case SettlerState::MOVING_TO_FOOD:
-            UpdateMovingToFood(deltaTime);
-            break;
-        case SettlerState::EATING:
-            UpdateEating(deltaTime);
-            break;
-        case SettlerState::MOVING_TO_BED:
-            UpdateMovingToBed(deltaTime);
-            break;
-        case SettlerState::IDLE:
-            // AI Logic for idle
-            if (m_profession == SettlerProfession::GATHERER && !m_currentGatherTask) {
-                // Check if inventory is full first
-                if (m_inventory.isFull()) {
-                    BuildingInstance* storage = FindNearestStorage(buildings);
-                    if (storage) {
-                        m_targetStorage = storage;
-                        MoveTo(storage->getPosition());
-                        m_state = SettlerState::MOVING_TO_STORAGE;
+            bool taskFound = false;
+            for (const auto& skill : sortedSkills) {
+                if (skill.type == SkillType::BUILDING && performBuilding) {
+                    if (g_buildingSystem) {
+                        auto buildTasks = g_buildingSystem->getActiveBuildTasks();
+                        if (!buildTasks.empty()) {
+                            float minDist = 1000.0f;
+                            BuildTask* nearestTask = nullptr;
+                            for (auto* task : buildTasks) {
+                                if (task->getWorkerCount() == 0) {
+                                    float d = Vector3Distance(position, task->getPosition());
+                                    if (d < minDist) {
+                                        minDist = d;
+                                        nearestTask = task;
+                                    }
+                                }
+                            }
+                            if (nearestTask) {
+                                assignBuildTask(nearestTask);
+                                taskFound = true;
+                            }
+                        }
                     }
-                } else {
-                    // Find nearest tree
+                }
+                else if (skill.type == SkillType::WOODCUTTING && gatherWood) {
                     float minDist = 100.0f;
                     Tree* nearest = nullptr;
-                    for (const auto& tree : trees) {
-                        if (tree->isActive() && !tree->isReserved() && !tree->isStump()) {
+                    for (const auto& treePtr : trees) {
+                        Tree* tree = treePtr.get();
+                        if (tree && tree->isActive() && !tree->isReserved() && !tree->isStump()) {
                             float d = Vector3Distance(position, tree->getPosition());
                             if (d < minDist) {
                                 minDist = d;
-                                nearest = tree.get();
+                                nearest = tree;
                             }
                         }
                     }
                     if (nearest) {
-                        AssignToChop(nearest);
+                        nearest->reserve(m_name);
+                        assignToChop(nearest);
+                        taskFound = true;
+                    }
+                }
+                else if (skill.type == SkillType::MINING && gatherStone) {
+                    float minDist = 100.0f;
+                    ResourceNode* nearest = nullptr;
+                    for (const auto& node : resourceNodes) {
+                        if (node->isActive() && !node->isReserved()) {
+                            float d = Vector3Distance(position, node->getPosition());
+                            if (d < minDist) {
+                                minDist = d;
+                                nearest = node.get();
+                            }
+                        }
+                    }
+                    if (nearest) {
+                        nearest->reserve(m_name);
+                        assignToMine(nearest);
+                        taskFound = true;
+                    }
+                }
+                else if (skill.type == SkillType::FARMING && gatherFood) {
+                    float minDist = 100.0f;
+                    Bush* nearest = nullptr;
+                    for (const auto& bush : bushes) {
+                        if (bush && bush->hasFruit) {
+                            float d = Vector3Distance(position, bush->position);
+                            if (d < minDist) {
+                                minDist = d;
+                                nearest = bush;
+                            }
+                        }
+                    }
+                    if (nearest) {
+                        m_currentGatherBush = nearest;
+                        MoveTo(nearest->position);
+                        m_state = SettlerState::GATHERING;
+                        m_gatherTimer = 0.0f;
+                        taskFound = true;
+                    }
+                }
+                // CRAFTING LOGIC
+                else if (craftItems) {
+                    auto craftingSys = GameEngine::getInstance().getSystem<CraftingSystem>();
+                    if (craftingSys) {
+                        CraftingTask* task = craftingSys->getAvailableTask(m_name);
+                        if (task) {
+                            // Znaleziono zadanie!
+                            BuildingInstance* workshop = FindNearestWorkshop(buildings);
+                            if (workshop) {
+                                m_currentCraftTaskId = task->taskId;
+                                m_targetWorkshop = workshop;
+                                MoveTo(workshop->getPosition());
+                                m_state = SettlerState::CRAFTING;
+                                m_craftingTimer = 0.0f;
+                                taskFound = true;
+                                // Zmień stan zadania w systemie (już zrobione w getAvailableTask)
+                                // Pobranie surowców
+                                if (craftingSys->consumeIngredients(task->recipeId)) {
+                                    std::cout << "[Settler] Rozpoczynam crafting (surowce pobrane): " << task->recipeId << std::endl;
+                                } else {
+                                    std::cerr << "[Settler] Błąd pobierania surowców! Anuluję zadanie." << std::endl;
+                                    craftingSys->cancelTask(task->taskId);
+                                    m_currentCraftTaskId = -1;
+                                    m_state = SettlerState::IDLE;
+                                    taskFound = false;
+                                }
+                            } else {
+                                // Brak warsztatu - anuluj zadanie (niech ktoś inny weźmie lub poczeka)
+                                craftingSys->cancelTask(task->taskId);
+                                std::cout << "[Settler] Brak warsztatu!" << std::endl;
+                            }
+                        }
                     }
                 }
-            }
-            break;
-            
-        case SettlerState::MOVING:
-            UpdateMovement(deltaTime, trees, buildings);
-            break;
-            
-        case SettlerState::GATHERING:
-            UpdateGathering(deltaTime, worldItems, buildings);
-            break;
-            
-        case SettlerState::BUILDING:
-            UpdateBuilding(deltaTime);
-            break;
-            
-        case SettlerState::SLEEPING:
-            UpdateSleeping(deltaTime);
-            break;
-
-        case SettlerState::HAULING:
-            UpdateHauling(deltaTime, buildings, worldItems);
-            break;
-            
-        case SettlerState::MOVING_TO_STORAGE:
-            UpdateMovingToStorage(deltaTime, buildings);
-            break;
-            
-        case SettlerState::DEPOSITING:
-            UpdateDepositing(deltaTime);
-            break;
-            
-        default:
-            break;
-    }
-    
-    // Sync position
-    auto posComp = getComponent<PositionComponent>();
-    if (posComp) posComp->setPosition(position);
-    
-    // Set action state string for UI
-    actionState = GetStateString();
-}
 
-void Settler::MoveTo(Vector3 destination) {
-    // Hysteresis: If we are already DEPOSITING and close enough to storage, don't switch back to MOVING unless target changed significantly
-    if (m_state == SettlerState::DEPOSITING && m_targetStorage) {
-        float dist = Vector3Distance(position, m_targetStorage->getPosition());
-        float hysteresisThreshold = 3.5f; // Larger than arrival threshold (2.5f)
-        
-        // If destination is essentially the storage position
-        if (Vector3Distance(destination, m_targetStorage->getPosition()) < 1.0f) {
-             if (dist < hysteresisThreshold) {
-                 return; // Stay in DEPOSITING
-             }
+                if (taskFound) break;
+            }
         }
-    }
-
-    m_targetPosition = destination;
-    m_state = SettlerState::MOVING;
+        break;
+    case SettlerState::MOVING:
+        UpdateMovement(deltaTime, trees, buildings);
+        break;
+    case SettlerState::MOVING_TO_STORAGE:
+        UpdateMovingToStorage(deltaTime, buildings);
+        break;
+    case SettlerState::DEPOSITING:    UpdateDepositing(deltaTime, buildings);    break;
+    case SettlerState::BUILDING:
+        UpdateBuilding(deltaTime);
+        break;
+    case SettlerState::SLEEPING:
+        UpdateSleeping(deltaTime);
+        break;
+    case SettlerState::PICKING_UP:
+        UpdatePickingUp(deltaTime, worldItems, buildings);
+        break;
+    case SettlerState::CRAFTING:
+        UpdateCrafting(deltaTime);
+        break;
+    case SettlerState::HAULING:
+        break;
+    case SettlerState::WAITING:
+        m_gatherTimer -= deltaTime;
+        if (m_gatherTimer <= 0.0f) {
+            std::cout << "[Settler] Koniec oczekiwania. Ponawiam probe." << std::endl;
+            m_state = SettlerState::IDLE;
+            m_gatherTimer = 0.0f;
+        }
+        break;
+    default:
+        break;
     
-    // Pathfinding
-    NavigationGrid* grid = GameSystem::getNavigationGrid();
-    if (grid) {
-        m_currentPath = grid->FindPath(position, m_targetPosition);
-        m_currentPathIndex = 0;
-    } else {
-        m_currentPath.clear();
-        m_currentPath.push_back(m_targetPosition);
-        m_currentPathIndex = 0;
     }
-}
 
-void Settler::Stop() {
-    m_state = SettlerState::IDLE;
-    m_currentPath.clear();
-    m_targetStorage = nullptr;
-    // Don't clear ignored storages here, as Stop() might be called during transitions
-    // where we want to persist the memory (e.g. during deposit fail loop).
-}
+auto posComp = getComponent<PositionComponent>();
+if (posComp) posComp->setPosition(position);
 
-void Settler::UpdateMovement(float deltaTime, const std::vector<std::unique_ptr<Tree>>& trees, const std::vector<BuildingInstance*>& buildings) {
-    (void)trees;
-    (void)buildings;
+actionState = GetStateString();
 
-    if (m_currentPath.empty()) {
-        // Reached end or no path
-        float dist = Vector3Distance(position, m_targetPosition);
-        float arrivalThreshold = 0.5f;
-        
-        // Increase threshold if target is a storage building to account for size
-        if (m_state == SettlerState::MOVING_TO_STORAGE && m_targetStorage) {
-            if (m_targetStorage->getBlueprintId() == "simple_storage") {
-                arrivalThreshold = 2.5f; // Adjusted for 3x3 size (half size 1.5 + some margin)
-            } else {
-                arrivalThreshold = 2.0f; // General storage buffer
-            }
-        }
 
-        if (dist < arrivalThreshold) {
-             // Arrived
-             // If we were moving to a task, switch state
-             if (m_currentGatherTask && m_currentGatherTask->getState() == GatheringTask::GatheringState::MOVING_TO_TARGET) {
-                 m_state = SettlerState::GATHERING;
-                 m_currentGatherTask->setState(GatheringTask::GatheringState::GATHERING);
-             } else if (m_currentBuildTask) {
-                 m_state = SettlerState::BUILDING;
-             } else if (m_targetStorage) { // Moving to storage
-                 m_state = SettlerState::DEPOSITING;
-                 // m_targetStorage = nullptr; // Do NOT clear target ref, we need it for depositing
-             } else {
-                 m_state = SettlerState::IDLE;
-             }
-        } else {
-             // Move directly if close
-             Vector3 direction = Vector3Subtract(m_targetPosition, position);
-             direction = Vector3Normalize(direction);
-             position = Vector3Add(position, Vector3Scale(direction, m_moveSpeed * deltaTime));
-             
-             // Face direction
-             m_rotation = atan2f(direction.x, direction.z) * RAD2DEG;
-        }
-        return;
-    }
-    
-    // Follow path
-    Vector3 nextPos = m_currentPath[m_currentPathIndex];
-    
-    // Check if close to next node
-    if (Vector3Distance(position, nextPos) < 0.2f) {
-        m_currentPathIndex++;
-        if (m_currentPathIndex >= m_currentPath.size()) {
-            m_currentPath.clear();
-            return;
-        }
-        nextPos = m_currentPath[m_currentPathIndex];
-    }
-    
-    Vector3 direction = Vector3Subtract(nextPos, position);
-    direction = Vector3Normalize(direction);
-    
-    // Rotation
-    float targetAngle = atan2f(direction.x, direction.z) * RAD2DEG;
-    m_rotation = Lerp(m_rotation, targetAngle, 5.0f * deltaTime); // Smooth turn
-    
-    // Move
-    Vector3 nextStep = Vector3Add(position, Vector3Scale(direction, m_moveSpeed * deltaTime));
-    
-    // Simple local avoidance (optional, if not relying purely on grid)
-    // For now, trust the grid/path
-    position = nextStep;
 }
 
-void Settler::assignTask(TaskType type, GameEntity* target, Vector3 pos) {
-    // Stop current task
-    Stop();
-    // Clear storage ignore list when assigned a manual task
-    ClearIgnoredStorages();
-    
-    if (type == TaskType::MOVE) {
-        MoveTo(pos);
-    } else if (type == TaskType::BUILD) {
-        // Try to find build task near pos
-        if (g_buildingSystem) {
-            BuildTask* task = g_buildingSystem->getBuildTaskAt(pos, 2.0f);
-            if (task) {
-                AssignBuildTask(task);
-            } else {
-                MoveTo(pos);
-            }
-        }
-    } else if (type == TaskType::GATHER) {
-        AssignToChop(target);
-    }
+void Settler::render() {
+Color color = m_isSelected ? YELLOW : BLUE;
+DrawCube(position, 0.5f, 1.0f, 0.5f, color);
+DrawCubeWires(position, 0.5f, 1.0f, 0.5f, BLACK);
+// Wizualizacja niesienia drewna
+const auto& items = m_inventory.getItems();
+bool hasWood = false;
+for (const auto& invItem : items) {
+if (invItem && invItem->item && invItem->item->getItemType() == ItemType::RESOURCE) {
+ResourceItem* resItem = dynamic_cast<ResourceItem*>(invItem->item.get());
+if (resItem && resItem->getResourceType() == "Wood") {
+hasWood = true;
+break;
 }
-
-void Settler::AssignBuildTask(BuildTask* task) {
-    if (!task) return;
-    m_currentBuildTask = task;
-    MoveTo(task->getPosition());
 }
-
-void Settler::UpdateBuilding(float deltaTime) {
-    if (!m_currentBuildTask) {
-        m_state = SettlerState::IDLE;
-        return;
-    }
-    
-    if (Vector3Distance(position, m_currentBuildTask->getPosition()) > 3.0f) {
-        // Re-evaluate move if too far
-        MoveTo(m_currentBuildTask->getPosition());
-        return;
-    }
-    
-    // Construct
-    if (m_currentBuildTask->isCompleted()) {
-        m_currentBuildTask = nullptr;
-        m_state = SettlerState::IDLE;
-        return;
-    }
-    
-    // Add progress
-    float buildPower = 10.0f + (m_skills.getSkillLevel(SkillType::BUILDING) * 2.0f);
-    m_currentBuildTask->advanceConstruction(buildPower * deltaTime);
 }
-
-void Settler::AssignToChop(GameEntity* tree) {
-    if (!tree) return;
-    
-    // Create gathering task
-    if (m_currentGatherTask) {
-        delete m_currentGatherTask;
-    }
-    // Create gathering task
-    if (m_currentGatherTask) {
-        delete m_currentGatherTask;
-    }
-    m_currentGatherTask = new GatheringTask(tree);
-    m_currentGatherTask->setState(GatheringTask::GatheringState::MOVING_TO_TARGET);
-    
-    // Reserve tree
-    Tree* t = dynamic_cast<Tree*>(tree);
-    if (t) {
-        t->reserve(m_name);
-    }
-    
-    // Start moving
-    MoveTo(tree->getPosition());
+if (hasWood) {
+Vector3 woodPos = position;
+woodPos.y += 1.2f; // nad głową
+DrawCube(woodPos, 0.3f, 0.3f, 0.3f, BROWN);
+DrawCubeWires(woodPos, 0.3f, 0.3f, 0.3f, BLACK);
 }
-void Settler::ForceGatherTarget(GameEntity* target) {
-    if (!target) return;
-    
-    // Clear any existing tasks
-    Stop();
-    ClearIgnoredStorages(); // Reset storage memory on forced task
-    if (m_currentGatherTask) {
-        delete m_currentGatherTask;
-        m_currentGatherTask = nullptr;
-    }
-    if (m_currentBuildTask) {
-        m_currentBuildTask = nullptr;
-    }
-    
-    // For now, only support Trees for gathering
-    Tree* tree = dynamic_cast<Tree*>(target);
-    if (tree) {
-        m_profession = SettlerProfession::GATHERER; // Force profession if needed, or just do it
-        m_targetStorage = nullptr; // Clear storage target
-        m_state = SettlerState::IDLE; // Reset state briefly to ensure clean transition
-        AssignToChop(tree);
-        
-        // Force state update to ensure we are moving immediately and UI updates
-        if (m_currentGatherTask) {
-            m_state = SettlerState::MOVING;
-            // Reset timers
-            m_gatherTimer = 0.0f;
-        }
-    } else {
-        // Maybe handle other resource types later (Bush, Rock)
-        MoveTo(target->getPosition());
-    }
 }
+InteractionResult Settler::interact(GameEntity* player) {
 
-void Settler::UpdateGathering(float deltaTime, std::vector<WorldItem>& worldItems, const std::vector<BuildingInstance*>& buildings) {
-    (void)worldItems; // Unused
+(void)player;
+
+InteractionResult result;
+
+result.success = true;
+
+result.message = "Rozmowa z " + m_name;
+
+return result;
 
-    if (!m_currentGatherTask) {
-        m_state = SettlerState::IDLE;
-        return;
-    }
-    
-    GameEntity* target = m_currentGatherTask->getTarget();
-    Tree* treeTarget = dynamic_cast<Tree*>(target);
-    
-    if (!target || (treeTarget && !treeTarget->isActive())) {
-        // Target gone
-        if (treeTarget) treeTarget->releaseReservation();
-        delete m_currentGatherTask;
-        m_currentGatherTask = nullptr;
-        m_state = SettlerState::IDLE;
-        return;
-    }
-    
-    // Check distance
-    float dist = Vector3Distance(position, target->getPosition());
-    float interactRange = 2.0f; 
-    
-    if (dist > interactRange) {
-        // Should be moving
-        MoveTo(target->getPosition());
-        return;
-    }
-    
-    // We are close, gather
-    // Face target
-    Vector3 direction = Vector3Subtract(target->getPosition(), position);
-    m_rotation = atan2f(direction.x, direction.z) * RAD2DEG;
-    
-    m_gatherTimer += deltaTime;
-    if (m_gatherTimer >= m_gatherInterval) {
-        m_gatherTimer = 0.0f;
-        
-        // Harvest
-        if (treeTarget) {
-            float gatherSkill = m_skills.getSkillLevel(SkillType::WOODCUTTING);
-            float harvestAmount = 10.0f + (gatherSkill * 2.0f); // Increased base and multiplier for faster gathering
-            
-            float actualHarvested = treeTarget->harvest(harvestAmount);
-            
-            if (actualHarvested > 0) {
-                // Create item and add to inventory
-                std::unique_ptr<Item> woodItem = std::make_unique<ResourceItem>("Wood", "Wood Log", "A resource for building.");
-                if (!m_inventory.addItem(std::move(woodItem), (int)actualHarvested)) {
-                    // Inventory full!
-                    printf("Inventory full! Moving to storage.\n");
-                    
-                    // Release tree reservation so others can take it
-                    treeTarget->releaseReservation();
-                    
-                    // Switch state to deposit
-                    // Clear ignored storages to give them a fresh check since we are just starting to deposit
-                    // But only if we weren't already trying to deposit (which is true here, we were gathering)
-                    ClearIgnoredStorages();
-                    
-                    BuildingInstance* storage = FindNearestStorage(buildings);
-                    if (storage) {
-                        m_targetStorage = storage;
-                        MoveTo(storage->getPosition());
-                        m_state = SettlerState::MOVING_TO_STORAGE; // Override MoveTo's MOVING state
-                    } else {
-                        // No storage? Just drop items or Idle?
-                        printf("No storage found!\n");
-                        m_state = SettlerState::IDLE; // Or just stand there full
-                    }
-                    return; 
-                }
-                
-                // Gain XP
-                m_skills.addSkillXP(SkillType::WOODCUTTING, actualHarvested * 2.0f);
-            }
-            
-            // If tree depleted
-            if (treeTarget->isStump() || treeTarget->getWoodAmount() <= 0) {
-                 treeTarget->releaseReservation();
-                 delete m_currentGatherTask;
-                 m_currentGatherTask = nullptr;
-                 
-                 // If we have items, maybe go deposit even if not full? 
-                 // Or just find next tree.
-                 // Let's find next tree (IDLE logic will pick it up)
-                 m_state = SettlerState::IDLE;
-            }
-        }
-    }
 }
+InteractionInfo Settler::getDisplayInfo() const {
 
-void Settler::UpdateMovingToStorage(float deltaTime, const std::vector<BuildingInstance*>& buildings) {
-    // Verify target still exists
-    bool exists = false;
-    if (m_targetStorage) {
-         for(auto b : buildings) if(b == m_targetStorage) exists = true;
-    }
-    
-    if (!m_targetStorage || !exists) {
-         m_targetStorage = FindNearestStorage(buildings);
-         if (!m_targetStorage) {
-             // Fallback: No storage found (all full or none built).
-             // Drop items to prevent deadlocks.
-             std::cout << "Settler " << m_name << ": No reachable storage found. Dropping items." << std::endl;
-             m_inventory.clear(); // TODO: Implement true "DropItemOnGround" logic
-             m_state = SettlerState::IDLE;
-             ClearIgnoredStorages(); // Clear memory for next attempt
-             return;
-         }
-    }
+InteractionInfo info;
 
-    float dist = Vector3Distance(position, m_targetStorage->getPosition());
-    float arrivalThreshold = 2.5f;
-    if (m_targetStorage->getBlueprintId() != "simple_storage") arrivalThreshold = 2.0f;
+info.objectName = m_name;
 
-    // Check if close enough to deposit
-    if (dist < arrivalThreshold) {
-        std::cout << "Settler " << m_name << " Arrived at Storage. Dist: " << dist << " Threshold: " << arrivalThreshold << std::endl;
-        m_state = SettlerState::DEPOSITING;
-        m_currentPath.clear();
-        return;
-    } else {
-         // Debug log to see why not arriving
-         // std::cout << "Settler " << m_name << " Moving to Storage. Dist: " << dist << " Threshold: " << arrivalThreshold << std::endl;
-    }
-    
-    // If not close enough, ensure we are moving towards it
-    if (Vector3Distance(m_targetPosition, m_targetStorage->getPosition()) > 0.5f || m_currentPath.empty()) {
-        MoveTo(m_targetStorage->getPosition());
-        m_state = SettlerState::MOVING_TO_STORAGE; // Force state back to MOVING_TO_STORAGE as MoveTo sets MOVING
-    }
+info.objectDescription = "Osadnik";
+
+return info;
 
-    UpdateMovement(deltaTime, {}, buildings);
 }
+std::string Settler::GetStateString() const {
 
-void Settler::UpdateDepositing(float deltaTime) {
-    (void)deltaTime;
+switch (m_state) {
 
-    if (!m_targetStorage) {
-        m_state = SettlerState::IDLE;
-        return;
-    }
+case SettlerState::IDLE: return "Bezczynny";
 
-    // === LAZY REPAIR CHECK START ===
-    std::string storageId = m_targetStorage->getStorageId();
-    if (storageId.empty()) {
-        std::cout << "[Settler] UpdateDepositing: Detected empty storageId. Attempting lazy repair." << std::endl;
-        
-        auto* storageSystem = GameEngine::getInstance().getSystem<StorageSystem>();
-        if (storageSystem) {
-            std::string newId = storageSystem->createStorage(StorageType::WAREHOUSE, "Colony");
-            if (!newId.empty()) {
-                m_targetStorage->setStorageId(newId);
-                std::cout << "[Settler] Lazy repair SUCCESS. Assigned new StorageID: " << newId << std::endl;
-                storageId = newId;
-            } else {
-                 std::cout << "[Settler] Lazy repair FAILED. Could not create storage." << std::endl;
-                 IgnoreStorage("INVALID_ID_GENERATED"); // Mark as ignored to avoid loop if retry happens
-                 m_targetStorage = nullptr;
-                 m_state = SettlerState::IDLE;
-                 return;
-            }
-        } else {
-            m_state = SettlerState::IDLE;
-            return;
-        }
-    }
-    // === LAZY REPAIR CHECK END ===
+case SettlerState::MOVING: return "Idzie";
 
-    float dist = Vector3Distance(position, m_targetStorage->getPosition());
-    float arrivalThreshold = 2.5f;
-    if (m_targetStorage->getBlueprintId() != "simple_storage") arrivalThreshold = 2.0f;
-    float hysteresisBuffer = 1.5f;
+case SettlerState::GATHERING: return "Zbiera";
 
-    // Only move back if significantly far away
-    if (dist > arrivalThreshold + hysteresisBuffer) {
-        m_state = SettlerState::MOVING_TO_STORAGE;
-        return;
-    }
+case SettlerState::CHOPPING: return "Rąbie";
 
-    auto* storageSystem = GameEngine::getInstance().getSystem<StorageSystem>();
-    if (!storageSystem) {
-        m_state = SettlerState::IDLE;
-        return;
-    }
+case SettlerState::MINING: return "Wydobywa";
 
-    storageId = m_targetStorage->getStorageId();
-    
-    // Iterate through items and try to add them
-    const auto& items = m_inventory.getItems();
-    if (m_inventory.isEmpty()) {
-        m_state = SettlerState::IDLE;
-        m_targetStorage = nullptr;
-        ClearIgnoredStorages(); // Success, clear ignored list
-        return;
-    }
+case SettlerState::BUILDING: return "Buduje";
 
-    bool anyFull = false;
-    
-    // Use a loop that allows modification (by index since we are iterating a vector of unique_ptrs)
-    // We iterate backwards or use a separate list of actions to avoid invalidating iterators if we were removing,
-    // but removeItemAt handles removal. However, m_items size is fixed (slots).
-    
-    for (size_t i = 0; i < items.size(); ++i) {
-        if (items[i] && items[i]->item) {
-            Resources::ResourceType type = Resources::ResourceType::None;
-            std::string name = items[i]->item->getDisplayName();
-            
-            // Map item name to ResourceType
-            if (name == "Wood" || name == "Wood Log") type = Resources::ResourceType::Wood;
-            else if (name == "Stone" || name == "Stone Chunk") type = Resources::ResourceType::Stone;
-            else if (name == "Metal" || name == "Iron Ore" || name == "Metal Ore") type = Resources::ResourceType::Metal;
-            else if (name == "Gold" || name == "Gold Ore") type = Resources::ResourceType::Gold;
-            else if (name == "Food" || name == "Raw Meat" || name == "Meat" || name == "Berries") type = Resources::ResourceType::Food;
+case SettlerState::SLEEPING: return "Śpi";
+
+case SettlerState::HUNTING: return "Poluje";
+
+case SettlerState::HAULING: return "Transportuje";
+
+case SettlerState::MOVING_TO_STORAGE: return "Idzie do magazynu";
+
+case SettlerState::DEPOSITING: return "Odkłada";
+
+case SettlerState::SEARCHING_FOR_FOOD: return "Szuka jedzenia";
+
+case SettlerState::MOVING_TO_FOOD: return "Idzie do jedzenia";
+
+case SettlerState::EATING: return "Je";
+
+case SettlerState::MOVING_TO_BED: return "Idzie spać";
+
+case SettlerState::PICKING_UP: return "Podnosi";
+
+case SettlerState::WANDER: return "Wędruje";
+
+case SettlerState::WAITING: return "Czeka";
+
+case SettlerState::CRAFTING: return "Tworzy";
+
+default: return "Nieznany";
+}
+
+
+std::string Settler::GetProfessionString() const {
+switch (m_profession) {
+case SettlerProfession::NONE: return "Brak";
+case SettlerProfession::BUILDER: return "Budowniczy";
+case SettlerProfession::GATHERER: return "Zbieracz";
+case SettlerProfession::HUNTER: return "Łowca";
+case SettlerProfession::CRAFTER: return "Rzemieślnik";
+default: return "Nieznany";
+}
+}
+
+
+void Settler::assignTask(TaskType type, GameEntity* target, Vector3 pos) {
+Action action;
+action.type = type;
+action.targetEntity = target;
+action.targetPosition = pos;
+m_actionQueue.push_back(action);
+}
+
+
+void Settler::clearTasks() {
+m_actionQueue.clear();
+m_state = SettlerState::IDLE;
+}
+void Settler::MoveTo(Vector3 destination) {
+// Sprawdź, czy cel się zmienił (z tolerancją) i czy mamy już ważną ścieżkę
+float distToLast = Vector3Distance(destination, m_lastPathTarget);
+if (distToLast < 0.1f && m_lastPathValid && !m_currentPath.empty()) {
+// Cel praktycznie ten sam, ścieżka już obliczona - użyj istniejącej
+std::cout << "[Settler] MoveTo: cel niezmieniony, używam istniejącej ścieżki." << std::endl;
+} else {
+// Oblicz nową ścieżkę za pomocą NavigationGrid
+NavigationGrid* grid = GameSystem::getNavigationGrid();
+if (grid) {
+std::vector<Vector3> path = grid->FindPath(position, destination);
+if (!path.empty()) {
+setPath(path);
+m_lastPathTarget = destination;
+m_lastPathValid = true;
+std::cout << "[Settler] MoveTo: wyznaczono ścieżkę o długości " << path.size() << " do ("
+<< destination.x << "," << destination.y << "," << destination.z << ")" << std::endl;
+} else {
+// Brak ścieżki (może cel nieosiągalny) - ruch bezpośredni
+std::cout << "[Settler] MoveTo: brak ścieżki, ruch bezpośredni." << std::endl;
+clearPath();
+m_lastPathValid = false;
+}
+} else {
+std::cout << "[Settler] MoveTo: brak NavigationGrid, ruch bezpośredni." << std::endl;
+clearPath();
+m_lastPathValid = false;
+}
+}
+
+m_targetPosition = destination;
+// Nie zmieniaj stanu jeśli już jest w stanie krytycznym (MOVING_TO_BED, MOVING_TO_FOOD, MOVING_TO_STORAGE)
+if (m_state != SettlerState::MOVING_TO_BED &&
+    m_state != SettlerState::MOVING_TO_FOOD &&
+    m_state != SettlerState::MOVING_TO_STORAGE) {
+    m_state = SettlerState::MOVING;
+}
+
+
+}
+void Settler::Stop() {
+
+m_state = SettlerState::IDLE;
+
+m_currentPath.clear();
+
+}
+void Settler::setPath(const std::vector<Vector3>& newPath) {
+
+m_currentPath = newPath;
+
+m_currentPathIndex = 0;
+
+}
+SavedTask Settler::serializeCurrentTask() const {
+
+SavedTask saved;
+
+saved.type = TaskType::WAIT;
+
+saved.targetPosition = m_targetPosition;
+
+saved.targetEntityId = -1;
+
+saved.duration = 0.0f;
+
+saved.hasTarget = false;
+
+return saved;
+
+}
+void Settler::deserializeTask(const SavedTask& savedTask) {
+
+(void)savedTask;
+
+}
+float Settler::getDistanceTo(Vector3 point) const {
+
+return Vector3Distance(position, point);
+
+}
+bool Settler::isAtPosition(Vector3 pos, float tolerance) const {
+
+return Vector3Distance(position, pos) < tolerance;
+
+}
+void Settler::updateNeeds(float deltaTime) {
+
+m_stats.update(deltaTime);
+
+}
+bool Settler::needsFood() const {
+
+return m_stats.getCurrentHunger() < m_stats.getFoodSearchThreshold();
+
+}
+bool Settler::needsSleep() const {
+
+return m_stats.isExhausted();
+
+}
+void Settler::takeDamage(float damage) {
+
+float current = m_stats.getCurrentHealth();
+
+m_stats.setHealth(current - damage);
+
+}
+void Settler::assignBed(BuildingInstance* bed) {
+
+m_assignedBed = bed;
+
+}
+void Settler::assignBuildTask(BuildTask* task) {
+
+m_currentBuildTask = task;
+
+if (task) {
+
+MoveTo(task->getPosition());
+
+m_state = SettlerState::MOVING;
+
+}
+
+}
+void Settler::clearBuildTask() {
+
+m_currentBuildTask = nullptr;
+
+}
+void Settler::assignToChop(GameEntity* tree) {
+
+if (tree) {
+
+clearTasks();
+
+Action move = Action::Move(tree->getPosition());
+
+m_actionQueue.push_back(move);
+
+Action chop;
+
+chop.type = TaskType::CHOP_TREE;
+
+chop.targetEntity = tree;
+
+m_actionQueue.push_back(chop);
+
+ExecuteNextAction();
+
+}
+
+}
+void Settler::assignToMine(GameEntity* rock) {
+
+if (rock) {
+
+clearTasks();
+
+Action move = Action::Move(rock->getPosition());
+
+m_actionQueue.push_back(move);
+
+Action mine;
+
+mine.type = TaskType::MINE_ROCK;
+
+mine.targetEntity = rock;
+
+m_actionQueue.push_back(mine);
+
+ExecuteNextAction();
+
+}
+
+}
+void Settler::forceGatherTarget(GameEntity* target) {
+
+if (target) {
+
+clearTasks();
+
+Action move = Action::Move(target->getPosition());
+
+m_actionQueue.push_back(move);
+
+Action interact;
+
+interact.targetEntity = target;
+
+Tree* tree = dynamic_cast<Tree*>(target);
+
+ResourceNode* rock = dynamic_cast<ResourceNode*>(target);
+
+if (tree) {
+
+interact.type = TaskType::CHOP_TREE;
+
+} else if (rock) {
+
+interact.type = TaskType::MINE_ROCK;
+
+} else {
+
+interact.type = TaskType::GATHER;
+
+}
+
+m_actionQueue.push_back(interact);
+
+ExecuteNextAction();
+
+}
+
+}
+void Settler::ExecuteNextAction() {
+
+if (m_actionQueue.empty()) return;
+
+Action& action = m_actionQueue.front();
+
+switch (action.type) {
+
+case TaskType::MOVE:
+
+MoveTo(action.targetPosition);
+
+break;
+
+case TaskType::CHOP_TREE:
+
+if (action.targetEntity) {
+
+m_currentTree = dynamic_cast<Tree*>(action.targetEntity);
+
+if (m_currentTree) {
+
+m_state = SettlerState::CHOPPING;
+
+m_gatherTimer = 0.0f;
+
+} else {
+
+m_state = SettlerState::IDLE;
+
+}
+
+}
+
+break;
+
+case TaskType::MINE_ROCK:
+
+if (action.targetEntity) {
+
+m_currentResourceNode = dynamic_cast<ResourceNode*>(action.targetEntity);
+
+if (m_currentResourceNode) {
+
+m_state = SettlerState::MINING;
+
+m_gatherTimer = 0.0f;
+
+} else {
+
+m_state = SettlerState::IDLE;
+
+}
+
+}
+
+break;
+
+case TaskType::WAIT:
+
+m_state = SettlerState::WAITING;
+
+break;
+
+case TaskType::PICKUP:
+
+MoveTo(action.targetPosition);
+
+m_state = SettlerState::PICKING_UP;
+
+break;
+
+default:
+
+break;
+
+}
+
+m_actionQueue.pop_front();
+
+}
+void Settler::UpdateMovement(float deltaTime, const std::vector<std::unique_ptr<Tree>>& trees, const std::vector<BuildingInstance*>& buildings) {
+(void)trees;
+(void)buildings;
+// Jeśli mamy ścieżkę, poruszaj się po waypointach
+if (!m_currentPath.empty() && m_currentPathIndex < (int)m_currentPath.size()) {
+Vector3 waypoint = m_currentPath[m_currentPathIndex];
+Vector3 direction = Vector3Subtract(waypoint, position);
+float distance = Vector3Length(direction);
+if (distance < 0.3f) { // osiągnięto waypoint
+m_currentPathIndex++;
+if (m_currentPathIndex >= (int)m_currentPath.size()) {
+// dotarliśmy do końca ścieżki
+m_currentPath.clear();
+m_currentPathIndex = 0;
+// przejdź do celu końcowego (m_targetPosition) bezpośrednio
+// (poniższa logika sprawdzi odległość do m_targetPosition)
+} else {
+// przejdź do następnego waypointa
+return;
+}
+} else {
+direction = Vector3Normalize(direction);
+Vector3 movement = Vector3Scale(direction, m_moveSpeed * deltaTime);
+position = Vector3Add(position, movement);
+return;
+}
+}
+// Bez ścieżki lub po jej zakończeniu: ruch bezpośredni do celu
+Vector3 direction = Vector3Subtract(m_targetPosition, position);
+float distance = Vector3Length(direction);
+if (distance < 0.5f) {
+// Jeśli szliśmy do warsztatu, przełącz na crafting
+if (m_state == SettlerState::MOVING && m_targetWorkshop && m_currentCraftTaskId != -1) {
+m_state = SettlerState::CRAFTING;
+m_craftingTimer = 0.0f;
+return;
+}
+
+m_state = SettlerState::IDLE;
+m_isMovingToCriticalTarget = false;
+return;
+
+}
+direction = Vector3Normalize(direction);
+Vector3 movement = Vector3Scale(direction, m_moveSpeed * deltaTime);
+position = Vector3Add(position, movement);
+
+}
+void Settler::UpdateGathering(float deltaTime, std::vector<WorldItem>& worldItems, const std::vector<BuildingInstance*>& buildings) {
+
+(void)worldItems;
+
+(void)buildings;
+
+m_gatherTimer += deltaTime;
+
+if (m_gatherTimer >= m_gatherInterval) {
+
+m_gatherTimer = 0.0f;
+
+m_state = SettlerState::IDLE;
+
+}
+
+}
+void Settler::UpdateBuilding(float deltaTime) {
+
+if (!m_currentBuildTask) {
+
+m_state = SettlerState::IDLE;
+
+return;
+
+}
+
+m_currentBuildTask->advanceConstruction(deltaTime * 10.0f);
+
+if (m_currentBuildTask->isCompleted()) {
+
+m_currentBuildTask = nullptr;
+void Settler::UpdateSleeping(float deltaTime) {
+m_stats.modifyEnergy(deltaTime * 5.0f);
+// Śpij aż energia osiągnie wysoki poziom (100%), aby uniknąć częstych oscylacji
+if (m_stats.getCurrentEnergy() >= 100.0f) {
+std::cout << "[Settler] " << m_name << " obudził się z energią: " << m_stats.getCurrentEnergy() << std::endl;
+m_state = SettlerState::IDLE;
+}
+}
+void Settler::UpdateMovingToStorage(float deltaTime, const std::vector<BuildingInstance*>& buildings) {
+
+(void)buildings;
+
+// Walidacja celu
+if (std::isnan(m_targetPosition.x) || std::isnan(m_targetPosition.y) || std::isnan(m_targetPosition.z) ||
+    std::abs(m_targetPosition.x) > 10000.0f || std::abs(m_targetPosition.z) > 10000.0f) {
+    std::cerr << "[Settler] CRITICAL: UpdateMovingToStorage - nieprawidłowy cel: ("
+              << m_targetPosition.x << ", " << m_targetPosition.y << ", " << m_targetPosition.z << ")" << std::endl;
+    Stop();
+    m_state = SettlerState::IDLE;
+    return;
+}
+
+Vector3 direction = Vector3Subtract(m_targetPosition, position);
+
+float distance = Vector3Length(direction);
+
+// Epsilon dla dotarcia
+if (distance < 1.0f) {
+
+    std::cout << "[Settler] Dotarłem do magazynu. Przechodzę do deponowania." << std::endl;
+
+    m_state = SettlerState::DEPOSITING;
+
+    return;
+
+}
+
+// Dodatkowe logowanie co 1s
+static float lastMoveLog = 0.0f;
+if (GetTime() - lastMoveLog > 1.0f) {
+    std::cout << "[Settler] MovingToStorage: pos=(" << position.x << "," << position.y << "," << position.z
+              << ") target=(" << m_targetPosition.x << "," << m_targetPosition.y << "," << m_targetPosition.z
+              << ") dist=" << distance << std::endl;
+    lastMoveLog = GetTime();
+}
+
+direction = Vector3Normalize(direction);
+
+Vector3 movement = Vector3Scale(direction, m_moveSpeed * deltaTime);
+
+position = Vector3Add(position, movement);
+
+}
+void Settler::UpdateDepositing(float deltaTime, const std::vector<BuildingInstance*>& buildings) {
+
+(void)deltaTime;
+
+if (!m_targetStorage || !m_targetStorage->isBuilt()) {
+
+    m_state = SettlerState::IDLE;
+
+    return;
+
+}
+
+std::string storageId = m_targetStorage->getStorageId();
+
+if (storageId.empty()) {
+
+    m_state = SettlerState::IDLE;
+
+    return;
+
+}
+
+auto storageSys = GameEngine::getInstance().getSystem<StorageSystem>();
+
+if (!storageSys) {
+
+    m_state = SettlerState::IDLE;
+
+    return;
+
+}
+
+std::cout << "[Settler] Rozpoczynam deponowanie w magazynie " << storageId << std::endl;
+
+std::vector<std::pair<int, int>> itemsToRemove;
+
+const auto& items = m_inventory.getItems();
+
+bool anyDeposited = false;
+
+for (size_t i = 0; i < items.size(); ++i) {
+
+    const auto& invItem = items[i];
+
+    if (!invItem || !invItem->item) continue;
+
+    if (invItem->item->getItemType() == ItemType::RESOURCE) {
+
+        ResourceItem* resItem = dynamic_cast<ResourceItem*>(invItem->item.get());
+
+        if (resItem) {
+
+            Resources::ResourceType type = Resources::ResourceType::None;
+
+            std::string typeStr = resItem->getResourceType();
+
+            if (typeStr == "Wood") type = Resources::ResourceType::Wood;
+
+            else if (typeStr == "Stone") type = Resources::ResourceType::Stone;
+
+            else if (typeStr == "Food") type = Resources::ResourceType::Food;
+
+            else if (typeStr == "Metal") type = Resources::ResourceType::Metal;
+
+            else if (typeStr == "Gold") type = Resources::ResourceType::Gold;
+
+            if (type != Resources::ResourceType::None) {
+
+                int32_t added = storageSys->addResourceToStorage(storageId, m_name, type, invItem->quantity);
 
-            if (type != Resources::ResourceType::None) {
-                int amount = items[i]->quantity;
-                int added = storageSystem->addResourceToStorage(storageId, "Colony", type, amount);
-                
                 if (added > 0) {
-                    // Decrease item quantity or remove if empty
-                    // NOTE: dropItem modifies m_items vector (by resetting unique_ptr)
-                    // but items reference is const and we iterate by index, so this is safe
-                    // as long as size doesn't change (it's fixed slots)
-                    m_inventory.dropItem((int)i, added);
-                    std::cout << "Settler " << m_name << ": Deposited " << added << " " << name << " to storage." << std::endl;
-                }
-                
-                if (added < amount) {
-                    // Storage was full for at least one item
-                    anyFull = true;
-                    std::cout << "Settler " << m_name << ": Storage full for " << name << " (added " << added << "/" << amount << ")" << std::endl;
+
+                    itemsToRemove.push_back({(int)i, added});
+
+                    anyDeposited = true;
+
+                    std::cout << "[Settler] Zdepsytowano " << added << " jednostek " << typeStr << " do magazynu " << storageId << std::endl;
+
+                } else {
+
+                    std::cout << "[Settler] Magazyn " << storageId << " nie może przyjąć " << typeStr << " (pełny lub brak miejsca)." << std::endl;
+
                 }
-            } else {
-                // For unknown items, we might want to drop them or log warning
-                std::cout << "Settler " << m_name << ": Unknown resource type for item: " << name << std::endl;
+
+            }
+
+        }
+
+    }
+
+}
+
+// Usuń zdeponowane itemy z ekwipunku
+
+for (int i = (int)itemsToRemove.size() - 1; i >= 0; --i) {
+
+    m_inventory.extractItem(itemsToRemove[i].first, itemsToRemove[i].second);
+
+}
+
+// Sprawdź czy pozostały jeszcze zasoby w ekwipunku
+
+bool hasRemainingResources = false;
+
+for (const auto& invItem : items) {
+
+    if (invItem && invItem->item && invItem->item->getItemType() == ItemType::RESOURCE) {
+
+        hasRemainingResources = true;
+
+        break;
+
+    }
+
+}
+
+if (hasRemainingResources) {
+
+    // Nie udało się zdeponować wszystkich zasobów (magazyn pełny)
+
+    std::cout << "[Settler] Magazyn " << storageId << " nie przyjął wszystkich zasobów. Oznaczam jako ignorowany i szukam innego." << std::endl;
+
+    ignoreStorage(storageId);
+
+    BuildingInstance* newStorage = FindNearestStorage(buildings);
+
+    if (newStorage) {
+
+        std::cout << "[Settler] Znaleziono alternatywny magazyn: " << newStorage->getStorageId() << std::endl;
+
+        m_targetStorage = newStorage;
+
+        MoveTo(newStorage->getPosition());
+
+        m_state = SettlerState::MOVING_TO_STORAGE;
+
+        return;
+
+    } else {
+
+        std::cout << "[Settler] Brak dostępnych magazynów. Przechodzę w stan oczekiwania (1s)." << std::endl;
+        
+                    // Awaryjne upuszczenie zasobów
+                    std::cout << "[Settler] Brak dostępnych magazynów. Upuszczam zasoby na ziemię." << std::endl;
+                    const auto& invItems = m_inventory.getItems();
+                    for (size_t i = 0; i < invItems.size(); ++i) {
+                        const auto& invItem = invItems[i];
+                        if (!invItem || !invItem->item || invItem->item->getItemType() != ItemType::RESOURCE) continue;
+                        ResourceItem* resItem = dynamic_cast<ResourceItem*>(invItem->item.get());
+                        if (!resItem) continue;
+                        // Stwórz kopię przedmiotu dla każdej jednostki
+                        for (int q = 0; q < invItem->quantity; ++q) {
+                            auto droppedItem = std::make_unique<ResourceItem>(resItem->getResourceType(), resItem->getDisplayName(), resItem->getDescription());
+                            // Upuść na ziemię w pobliżu settlera
+                            if (GameEngine::dropItemCallback) {
+                                Vector3 dropPos = position;
+                                dropPos.x += (float)(rand()%10 - 5) * 0.1f;
+                                dropPos.z += (float)(rand()%10 - 5) * 0.1f;
+                                dropPos.y = 0.5f;
+                                GameEngine::dropItemCallback(dropPos, droppedItem.release());
+                            }
+                        }
+                    }
+                    // Wyczyść inventory z zasobów
+                    m_inventory.clear(); // lub iteracyjnie usuń, ale clear jest prostsze
+                    m_state = SettlerState::IDLE;
+                    return;
+
+    }
+
+}
+
+// Jeśli nie ma już zasobów, zakończ deponowanie
+
+if (anyDeposited) {
+
+    std::cout << "[Settler] Wszystkie zasoby zdeponowane. Wracam do IDLE." << std::endl;
+
+} else {
+
+    std::cout << "[Settler] Nie zdeponowano żadnych zasobów (magazyn pełny). Szukam innego magazynu." << std::endl;
+
+    ignoreStorage(storageId);
+
+    BuildingInstance* newStorage = FindNearestStorage(buildings);
+
+    if (newStorage) {
+
+        std::cout << "[Settler] Znaleziono alternatywny magazyn: " << newStorage->getStorageId() << std::endl;
+
+        m_targetStorage = newStorage;
+
+        MoveTo(newStorage->getPosition());
+
+        m_state = SettlerState::MOVING_TO_STORAGE;
+
+        return;
+
+    } else {
+
+        std::cout << "[Settler] Brak dostępnych magazynów. Przechodzę w stan oczekiwania (1s)." << std::endl;
+        
+            m_state = SettlerState::WAITING;
+        
+            m_gatherTimer = 1.0f;
+
+        return;
+
+    }
+
+}
+
+m_state = SettlerState::IDLE;
+
+}
+void Settler::UpdatePickingUp(float deltaTime, std::vector<WorldItem>& worldItems, const std::vector<BuildingInstance*>& buildings) {
+
+float minDist = 2.0f;
+
+int pickedIndex = -1;
+
+for (size_t i = 0; i < worldItems.size(); ++i) {
+
+if (worldItems[i].pendingRemoval) continue;
+
+if (worldItems[i].item && worldItems[i].item->getItemType() == ItemType::RESOURCE) {
+
+float d = Vector3Distance(position, worldItems[i].position);
+
+if (d < minDist) {
+
+if (m_inventory.addItem(std::move(worldItems[i].item))) {
+
+worldItems[i].pendingRemoval = true;
+
+pickedIndex = (int)i;
+
+break;
+
+}
+
+}
+
+}
+
+}
+
+if (pickedIndex != -1) {
+    // Pobierz informacje o podniesionym przedmiocie
+    WorldItem& picked = worldItems[pickedIndex];
+    std::string itemName = "unknown";
+    if (picked.item) {
+        if (picked.item->getItemType() == ItemType::RESOURCE) {
+            ResourceItem* res = dynamic_cast<ResourceItem*>(picked.item.get());
+            if (res) {
+                itemName = res->getResourceType();
             }
+        } else {
+            itemName = "non-resource";
         }
     }
+    std::cout << "[Settler] Podniesiono przedmiot: " << itemName << ". Wymuszam dostarczenie do magazynu (niezależnie od flagi haulToStorage)." << std::endl;
+
+    BuildingInstance* storage = FindNearestStorage(buildings);
+    
+    if (storage) {
     
-    if (m_inventory.isEmpty()) {
-        // All deposited successfully
+        std::cout << "[Settler] Znaleziono magazyn ID: " << storage->getStorageId() << " w odl: " << Vector3Distance(position, storage->getPosition()) << std::endl;
+    
+        m_targetStorage = storage;
+    
+        MoveTo(storage->getPosition());
+    
+        m_state = SettlerState::MOVING_TO_STORAGE;
+    
+    } else {
+    
+        std::cout << "[Settler] FALLBACK DROP: Nie znaleziono magazynu po podniesieniu, upuszczam zasoby na ziemię." << std::endl;
+        // Upuść wszystkie zasoby z ekwipunku
+        const auto& invItems = m_inventory.getItems();
+        for (size_t i = 0; i < invItems.size(); ++i) {
+            const auto& invItem = invItems[i];
+            if (!invItem || !invItem->item || invItem->item->getItemType() != ItemType::RESOURCE) continue;
+            ResourceItem* resItem = dynamic_cast<ResourceItem*>(invItem->item.get());
+            if (!resItem) continue;
+            for (int q = 0; q < invItem->quantity; ++q) {
+                auto droppedItem = std::make_unique<ResourceItem>(resItem->getResourceType(), resItem->getDisplayName(), resItem->getDescription());
+                if (GameEngine::dropItemCallback) {
+                    Vector3 dropPos = position;
+                    dropPos.x += (float)(rand()%10 - 5) * 0.1f;
+                    dropPos.z += (float)(rand()%10 - 5) * 0.1f;
+                    dropPos.y = 0.5f;
+                    GameEngine::dropItemCallback(dropPos, droppedItem.release());
+                }
+            }
+        }
+        m_inventory.clear();
         m_state = SettlerState::IDLE;
-        m_targetStorage = nullptr;
-        ClearIgnoredStorages();
+    }
+} else {
+
+    Vector3 direction = Vector3Subtract(m_targetPosition, position);
+
+    float distance = Vector3Length(direction);
+
+    if (distance > 0.5f) {
+
+        direction = Vector3Normalize(direction);
+
+        Vector3 movement = Vector3Scale(direction, m_moveSpeed * deltaTime);
+
+        position = Vector3Add(position, movement);
+
     } else {
-        // Still have items
-        if (anyFull) {
-            // Current storage is full for some items we carry
-            std::cout << "Settler " << m_name << ": Storage " << storageId << " is full. Looking for another." << std::endl;
-            IgnoreStorage(storageId);
-            m_targetStorage = nullptr; // Clear current target to force find new one
-            m_state = SettlerState::MOVING_TO_STORAGE; // Will trigger FindNearestStorage in update
+
+        m_state = SettlerState::IDLE;
+
+    }
+}
+
+
+}
+void Settler::UpdateSearchingForFood(float deltaTime, const std::vector<Bush*>& bushes) {
+
+(void)deltaTime;
+
+Bush* nearestFood = FindNearestFood(bushes);
+
+if (nearestFood) {
+
+m_targetFoodBush = nearestFood;
+
+MoveTo(nearestFood->position);
+
+m_state = SettlerState::MOVING_TO_FOOD;
+
+m_isMovingToCriticalTarget = true;
+
+} else {
+
+m_state = SettlerState::IDLE;
+
+m_isMovingToCriticalTarget = false;
+
+}
+
+}
+void Settler::UpdateMovingToFood(float deltaTime) {
+
+Vector3 direction = Vector3Subtract(m_targetPosition, position);
+
+float distance = Vector3Length(direction);
+
+if (distance < 0.5f) {
+
+m_state = SettlerState::EATING;
+
+m_isMovingToCriticalTarget = false;
+
+return;
+
+}
+
+direction = Vector3Normalize(direction);
+
+Vector3 movement = Vector3Scale(direction, m_moveSpeed * deltaTime);
+
+position = Vector3Add(position, movement);
+
+}
+void Settler::UpdateEating(float deltaTime) {
+
+m_eatingTimer += deltaTime;
+
+if (m_eatingTimer >= 2.0f) {
+
+m_eatingTimer = 0.0f;
+
+m_stats.setHunger(100.0f);
+
+m_state = SettlerState::IDLE;
+
+}
+
+}
+void Settler::UpdateCrafting(float deltaTime) {
+
+if (m_currentCraftTaskId == -1) {
+
+m_state = SettlerState::IDLE;
+
+return;
+
+}
+
+m_craftingTimer += deltaTime;
+// Czas craftingu - pobierz z zadania? Na razie hardcode 3.0s lub pobieramy z recipe.
+// Uproszczenie: 3.0s
+if (m_craftingTimer >= 3.0f) {
+    m_craftingTimer = 0.0f;
+    
+    auto craftingSys = GameEngine::getInstance().getSystem<CraftingSystem>();
+    if (craftingSys) {
+        auto item = craftingSys->completeTask(m_currentCraftTaskId);
+        if (item) {
+            // Dodaj do ekwipunku
+            if (m_inventory.addItem(std::move(item))) {
+                std::cout << "[Settler] Crafting zakonczony sukcesem!" << std::endl;
+            } else {
+                std::cerr << "[Settler] Ekwipunek pelny, przedmiot upuszczony!" << std::endl;
+                // TODO: Upuść na ziemię (world items)
+            }
+        }
+    }
+    
+    m_currentCraftTaskId = -1;
+    m_targetWorkshop = nullptr;
+    m_state = SettlerState::IDLE;
+}
+
+
+}
+BuildingInstance* Settler::FindNearestStorage(const std::vector<BuildingInstance*>& buildings) {
+static float lastDebugLogTime = -1.0f;
+BuildingInstance* nearest = nullptr;
+float minDst = 10000.0f;
+auto storageSys = GameEngine::getInstance().getSystem<StorageSystem>();
+if (!storageSys) {
+std::cout << "[Settler] Brak systemu magazynowego!" << std::endl;
+return nullptr;
+}
+// Pomocnicza lambda do sprawdzania poprawności pozycji
+auto isValidPosition = [](const Vector3& pos) -> bool {
+return !std::isnan(pos.x) && !std::isnan(pos.y) && !std::isnan(pos.z) &&
+!std::isinf(pos.x) && !std::isinf(pos.y) && !std::isinf(pos.z) &&
+std::abs(pos.x) < 10000.0f && std::abs(pos.y) < 10000.0f && std::abs(pos.z) < 10000.0f;
+};
+// Diagnostyka: wypisz liczbę budynków i szczegóły (throttle 1s)
+float currentTime = GetTime(); // funkcja z raylib
+bool shouldLog = (currentTime - lastDebugLogTime > 1.0f) || (lastDebugLogTime < 0);
+if (shouldLog) {
+std::cout << "[Settler] DEBUG FindNearestStorage: buildingsTotal = " << buildings.size() << std::endl;
+int idx = 0;
+for (auto* b : buildings) {
+if (!b) {
+std::cout << "  [" << idx << "] nullptr" << std::endl;
+idx++;
+continue;
+}
+std::string storageId = b->getStorageId();
+std::string blueprintId = b->getBlueprintId();
+bool built = b->isBuilt();
+BuildingCategory category = BuildingCategory::STRUCTURE;
+if (b->getBlueprint()) {
+category = b->getBlueprint()->getCategory();
+}
+std::string categoryStr = "UNKNOWN";
+switch (category) {
+case BuildingCategory::STORAGE: categoryStr = "STORAGE"; break;
+case BuildingCategory::RESIDENTIAL: categoryStr = "RESIDENTIAL"; break;
+case BuildingCategory::PRODUCTION: categoryStr = "PRODUCTION"; break;
+case BuildingCategory::FURNITURE: categoryStr = "FURNITURE"; break;
+default: categoryStr = "STRUCTURE"; break;
+}
+Vector3 pos = b->getPosition();
+bool validPos = isValidPosition(pos);
+std::cout << "  [" << idx << "] id=" << storageId << " blueprint=" << blueprintId
+<< " built=" << built << " category=" << categoryStr
+<< " pos=(" << pos.x << "," << pos.y << "," << pos.z << ")"
+<< " valid=" << (validPos ? "true" : "false") << std::endl;
+idx++;
+    idx++;
+}
+lastDebugLogTime = currentTime;
+
+}
+// Etap 1: Szukaj budynku z kategorią STORAGE i canAddResource == true
+for (auto* b : buildings) {
+if (!b) {
+if (shouldLog) {
+std::cout << "[Settler] DEBUG: Odrzucono nullptr" << std::endl;
+}
+continue;
+}
+std::string storageId = b->getStorageId();
+std::string blueprintId = b->getBlueprintId();
+
+    // Sprawdź czy zbudowany (z wyjątkiem stockpile) - użyj substring
+    bool isStockpile = (blueprintId.find("stockpile") != std::string::npos);
+    if (!b->isBuilt() && !isStockpile) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono " << storageId << " (" << blueprintId << ") - !isBuilt()" << std::endl;
+        }
+        continue;
+    }
+    if (storageId.empty()) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono " << blueprintId << " - brak/invalid storageId" << std::endl;
+        }
+        continue;
+    }
+
+    // Sprawdź kategorię budynku
+    BuildingCategory category = BuildingCategory::STRUCTURE;
+    if (b->getBlueprint()) {
+        category = b->getBlueprint()->getCategory();
+    }
+
+    // Tylko STORAGE w etapie 1, ale stockpile traktuj jako STORAGE niezależnie od kategorii
+    if (category != BuildingCategory::STORAGE && !isStockpile) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono " << storageId << " (" << blueprintId << ") - kategoria " << static_cast<int>(category) << " nie STORAGE" << std::endl;
+        }
+        continue;
+    }
+
+    // Sprawdź czy magazyn jest ignorowany
+    if (isStorageIgnored(storageId)) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono " << storageId << " - ignorowany (lista ignored)." << std::endl;
+        }
+        continue;
+    }
+
+    // Sprawdź pojemność
+    bool canAcceptAny = false;
+    const auto& items = m_inventory.getItems();
+
+    for (const auto& invItem : items) {
+        if (!invItem || !invItem->item || invItem->item->getItemType() != ItemType::RESOURCE) continue;
+        ResourceItem* resItem = dynamic_cast<ResourceItem*>(invItem->item.get());
+        if (!resItem) continue;
+        std::string typeStr = resItem->getResourceType();
+        Resources::ResourceType type = Resources::ResourceType::None;
+        if (typeStr == "Wood") type = Resources::ResourceType::Wood;
+        else if (typeStr == "Stone") type = Resources::ResourceType::Stone;
+        else if (typeStr == "Food") type = Resources::ResourceType::Food;
+        else if (typeStr == "Metal") type = Resources::ResourceType::Metal;
+        else if (typeStr == "Gold") type = Resources::ResourceType::Gold;
+
+                  if (type != Resources::ResourceType::None) {
+                      // Log parametrów canAddResource
+                      std::cout << "[Settler] DEBUG: Sprawdzanie canAddResource dla storageId=" << storageId
+                                << ", resourceType=" << typeStr << ", quantity=" << invItem->quantity << std::endl;
+                      if (storageSys->canAddResource(storageId, type, invItem->quantity)) {
+                          canAcceptAny = true;
+                          break;
+                      } else {
+                          std::cout << "[Settler] DEBUG: Odrzucono - canAddResource zwróciło false dla " << typeStr << std::endl;
+                      }
+                  } else {
+                      // Zasób unknown
+                      std::cout << "[Settler] WARNING: Nieznany typ zasobu: " << typeStr << std::endl;
+                      // TODO: Rozważyć obsługę nieznanych zasobów lub walidację typów
+                      // Na razie odrzucamy, ale logujemy ostrzeżenie
+                  }
+    }
+
+    // Jeśli nie mamy żadnych zasobów (np. jeszcze nie podnieśliśmy), to załóżmy że magazyn może przyjąć cokolwiek (sprawdź wolne sloty)
+    if (!canAcceptAny && items.empty()) {
+        StorageSystem::StorageInstance* storage = storageSys->getStorage(storageId);
+        if (storage && storage->getFreeSlots() > 0) {
+            canAcceptAny = true;
+        } else {
+            if (shouldLog) {
+                std::cout << "[Settler] DEBUG: Odrzucono " << storageId << " - brak wolnych slotów." << std::endl;
+            }
+            continue;
+        }
+    }
+
+    if (!canAcceptAny) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono " << storageId << " - storageSys->canAddResource(...) == false dla wszystkich zasobów." << std::endl;
+        }
+        continue;
+    }
+
+    // Sprawdź czy pozycja jest prawidłowa
+    Vector3 buildingPos = b->getPosition();
+    if (!isValidPosition(buildingPos)) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono " << storageId << " - nieprawidłowa pozycja ("
+                      << buildingPos.x << ", " << buildingPos.y << ", " << buildingPos.z << ")" << std::endl;
+        }
+        continue;
+    }
+    
+    // Wszystkie warunki spełnione – oblicz odległość
+    float d = Vector3Distance(position, buildingPos);
+    if (shouldLog) {
+        std::cout << "[Settler] DEBUG: Kandydat STORAGE " << storageId << " (" << blueprintId << ") zaakceptowany, "
+                  << "settlerPos=(" << position.x << "," << position.y << "," << position.z << "), "
+                  << "targetPos=(" << buildingPos.x << "," << buildingPos.y << "," << buildingPos.z << "), "
+                  << "odległość = " << d << std::endl;
+    }
+    if (d < minDst) {
+        minDst = d;
+        nearest = b;
+    }
+}
+
+if (nearest) {
+    std::cout << "[Settler] Znaleziono magazyn (kategoria STORAGE): " << nearest->getStorageId() << " w odległości " << minDst << std::endl;
+    return nearest;
+}
+
+// Etap 2: fallback - dowolny budynek (nie RESIDENTIAL) gdzie canAddResource == true
+std::cout << "[Settler] Nie znaleziono magazynu kategorii STORAGE. Przechodzę do fallback (dowolny budynek)." << std::endl;
+nearest = nullptr;
+minDst = 10000.0f;
+
+for (auto* b : buildings) {
+    if (!b) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono fallback nullptr" << std::endl;
+        }
+        continue;
+    }
+    std::string storageId = b->getStorageId();
+    std::string blueprintId = b->getBlueprintId();
+    bool isStockpile = (blueprintId == "stockpile");
+
+    // Dla stockpile ignorujemy isBuilt() - użyj substring
+    if (!b->isBuilt() && !isStockpile) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono fallback " << storageId << " (" << blueprintId << ") - !isBuilt()" << std::endl;
+        }
+        continue;
+    }
+    if (storageId.empty()) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono fallback " << blueprintId << " - brak/invalid storageId" << std::endl;
+        }
+        continue;
+    }
+
+    BuildingCategory category = BuildingCategory::STRUCTURE;
+    if (b->getBlueprint()) {
+        category = b->getBlueprint()->getCategory();
+    }
+
+    // Nie odrzucamy RESIDENTIAL - decyduje canAddResource.
+
+    // Odrzuć jeśli ignorowany
+    if (isStorageIgnored(storageId)) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono fallback " << storageId << " - ignorowany (lista ignored)." << std::endl;
+        }
+        continue;
+    }
+
+    // Sprawdź pojemność
+    bool canAcceptAny = false;
+    const auto& items = m_inventory.getItems();
+
+    for (const auto& invItem : items) {
+        if (!invItem || !invItem->item || invItem->item->getItemType() != ItemType::RESOURCE) continue;
+        ResourceItem* resItem = dynamic_cast<ResourceItem*>(invItem->item.get());
+        if (!resItem) continue;
+        std::string typeStr = resItem->getResourceType();
+        Resources::ResourceType type = Resources::ResourceType::None;
+        if (typeStr == "Wood") type = Resources::ResourceType::Wood;
+        else if (typeStr == "Stone") type = Resources::ResourceType::Stone;
+        else if (typeStr == "Food") type = Resources::ResourceType::Food;
+        else if (typeStr == "Metal") type = Resources::ResourceType::Metal;
+        else if (typeStr == "Gold") type = Resources::ResourceType::Gold;
+
+        if (type != Resources::ResourceType::None) {
+            if (storageSys->canAddResource(storageId, type, invItem->quantity)) {
+                canAcceptAny = true;
+                break;
+            }
+        }
+    }
+
+    if (!canAcceptAny && items.empty()) {
+        StorageSystem::StorageInstance* storage = storageSys->getStorage(storageId);
+        if (storage && storage->getFreeSlots() > 0) {
+            canAcceptAny = true;
         } else {
-            // If we couldn't deposit but it wasn't because it returned 'added < amount' (e.g. type mismatch or other logic)
-            // Maybe we are carrying non-resource items?
-            // For now, just go idle to prevent getting stuck in DEPOSITING state
-             std::cout << "Settler " << m_name << ": Could not deposit remaining items (unknown type?). Going IDLE." << std::endl;
-             m_state = SettlerState::IDLE;
-             m_targetStorage = nullptr;
+            if (shouldLog) {
+                std::cout << "[Settler] DEBUG: Odrzucono fallback " << storageId << " - brak wolnych slotów." << std::endl;
+            }
+            continue;
+        }
+    }
+
+    if (!canAcceptAny) {
+        if (shouldLog) {
+            std::cout << "[Settler] DEBUG: Odrzucono fallback " << storageId << " - storageSys->canAddResource(...) == false dla wszystkich zasobów." << std::endl;
+        }
+        continue;
+    }
+
+// Sprawdź czy pozycja jest prawidłowa
+Vector3 buildingPos = b->getPosition();
+if (!isValidPosition(buildingPos)) {
+if (shouldLog) {
+std::cout << "[Settler] DEBUG: Odrzucono fallback " << storageId << " - nieprawidłowa pozycja ("
+<< buildingPos.x << ", " << buildingPos.y << ", " << buildingPos.z << ")" << std::endl;
+}
+continue;
+}
+float d = Vector3Distance(position, buildingPos);
+if (shouldLog) {
+std::cout << "[Settler] Kandydat fallback " << storageId << " (" << blueprintId << ") zaakceptowany, "
+<< "settlerPos=(" << position.x << "," << position.y << "," << position.z << "), "
+<< "targetPos=(" << buildingPos.x << "," << buildingPos.y << "," << buildingPos.z << "), "
+<< "odległość = " << d << std::endl;
+}
+if (d < minDst) {
+minDst = d;
+nearest = b;
+}
+
+}
+
+if (nearest) {
+std::cout << "[Settler] Znaleziono magazyn (fallback): " << nearest->getStorageId() << " w odległości " << minDst << std::endl;
+} else {
+std::cout << "[Settler] Nie znaleziono żadnego dostępnego magazynu (ani STORAGE, ani fallback)." << std::endl;
+// Wymuszony log diagnostyczny przed zwróceniem nullptr
+std::cout << "[Settler] DIAGNOSTIC: buildingsTotal = " << buildings.size() << std::endl;
+int stockpileCount = 0;
+for (size_t i = 0; i < buildings.size() && i < 20; ++i) {
+auto* b = buildings[i];
+if (!b) {
+std::cout << "  [" << i << "] nullptr" << std::endl;
+continue;
+}
+std::string storageId = b->getStorageId();
+std::string blueprintId = b->getBlueprintId();
+bool built = b->isBuilt();
+BuildingCategory category = BuildingCategory::STRUCTURE;
+if (b->getBlueprint()) {
+category = b->getBlueprint()->getCategory();
+}
+std::string categoryStr = "UNKNOWN";
+switch (category) {
+case BuildingCategory::STORAGE: categoryStr = "STORAGE"; break;
+case BuildingCategory::RESIDENTIAL: categoryStr = "RESIDENTIAL"; break;
+case BuildingCategory::PRODUCTION: categoryStr = "PRODUCTION"; break;
+case BuildingCategory::FURNITURE: categoryStr = "FURNITURE"; break;
+default: categoryStr = "STRUCTURE"; break;
+}
+Vector3 pos = b->getPosition();
+std::cout << "  [" << i << "] id=" << storageId << " blueprint=" << blueprintId
+<< " built=" << built << " category=" << categoryStr
+<< " pos=(" << pos.x << "," << pos.y << "," << pos.z << ")" << std::endl;
+// Sprawdź czy blueprintId zawiera "stockpile"
+if (blueprintId.find("stockpile") != std::string::npos) {
+stockpileCount++;
+}
+}
+std::cout << "[Settler] DIAGNOSTIC: stockpileCount = " << stockpileCount << std::endl;
+}
+return nearest;
+}
+
+BuildingInstance* Settler::FindNearestWorkshop(const std::vector<BuildingInstance*>& buildings) {
+
+BuildingInstance* nearest = nullptr;
+
+float minDst = 10000.0f;
+
+for (auto* b : buildings) {
+    if (!b || !b->isBuilt()) continue;
+    // Sprawdź czy to workshop (po ID blueprintu lub kategorii)
+    // Zakładamy, że workshop to np. "workshop" lub kategoria CRAFTING (jeśli dodamy)
+    // Na razie sprawdzamy blueprint ID
+    // ALE nie mam wglądu w listę blueprintów. Załóżmy, że każdy budynek może być warsztatem jeśli ma odpowiednie capability.
+    // Dla testu: każdy budynek o ID zawierającym "workshop" lub po prostu dowolny budynek jeśli nie ma workshopu?
+    // Nie, muszę znaleźć konkretny.
+    // Użyjmy "stockpile" jako warsztatu tymczasowo, lub "house" jeśli nie ma workshopu.
+    // Ale lepiej: dodajmy blueprint workshopu później.
+    // Tutaj szukamy "simple_workshop" (przykładowa nazwa).
+    // Dla testu: szukamy 'simple_storage' też jako workshopu (multitool)
+    
+    bool isWorkshop = (b->getBlueprintId() == "simple_storage"); // HACK for testing
+    
+    if (isWorkshop) {
+        float d = Vector3Distance(position, b->getPosition());
+        if (d < minDst) {
+            minDst = d;
+            nearest = b;
         }
     }
 }
+return nearest;
+
+
+}
+Bush* Settler::FindNearestFood(const std::vector<Bush*>& bushes) {
+
+Bush* nearest = nullptr;
+
+float minDst = 10000.0f;
+
+for (auto* b : bushes) {
+
+if (b->hasFruit) {
+
+float d = Vector3Distance(position, b->position);
+
+if (d < minDst) {
+
+minDst = d;
+
+nearest = b;
+
+}
+
+}
+
+}
+
+return nearest;
+
+}
+void Settler::UpdateChopping(float deltaTime) {
+
+if (!m_currentTree || !m_currentTree->isActive()) {
+
+m_state = SettlerState::IDLE;
+
+return;
+
+}
+
+if (m_pendingReevaluation) {
+
+if (m_currentTree) {
+
+m_currentTree->releaseReservation();
+
+}
+
+m_pendingReevaluation = false;
+
+InterruptCurrentAction();
+
+return;
+
+}
 
-BuildingInstance* Settler::FindNearestStorage(const std::vector<BuildingInstance*>& buildings) {
-    BuildingInstance* nearest = nullptr;
-    float minDist = 10000.0f;
-    
-    for (auto* b : buildings) {
-        // Check if storage ID is ignored
-        if (IsStorageIgnored(b->getStorageId())) continue;
+m_gatherTimer += deltaTime;
+
+if (m_gatherTimer >= 1.0f) {
+
+m_gatherTimer = 0.0f;
+
+if (CheckForJobFlagActivation()) {
+
+if (m_currentTree) {
+
+m_currentTree->releaseReservation();
 
-        // Check if building is storage.
-        const BuildingBlueprint* bp = b->getBlueprint();
-        bool isStorage = false;
-        
-        if (bp) {
-            if (bp->getCategory() == BuildingCategory::STORAGE) isStorage = true;
-            if (bp->getName() == "storehouse" || bp->getName() == "Warehouse" ||
-                bp->getName() == "Stockpile" || bp->getName() == "Town Hall") isStorage = true;
-        }
-        
-        if (b->getBlueprintId() == "simple_storage") isStorage = true;
-        
-        if (isStorage) {
-            float d = Vector3Distance(position, b->getPosition());
-            if (d < minDist) {
-                minDist = d;
-                nearest = b;
-            }
-        }
-    }
-    
-    if (nearest) {
-        // === LAZY REPAIR CHECK START ===
-        if (nearest->getStorageId().empty()) {
-             std::cout << "[Settler] FindNearestStorage: Found storage but ID is empty. Attempting lazy repair for blueprint: " << nearest->getBlueprintId() << std::endl;
-             auto* storageSystem = GameEngine::getInstance().getSystem<StorageSystem>();
-             if (storageSystem) {
-                 std::string newId = storageSystem->createStorage(StorageType::WAREHOUSE, "Colony");
-                 if (!newId.empty()) {
-                     nearest->setStorageId(newId);
-                     std::cout << "[Settler] Lazy repair SUCCESS. Assigned new StorageID: " << newId << std::endl;
-                 } else {
-                     std::cout << "[Settler] Lazy repair FAILED. Could not create storage." << std::endl;
-                 }
-             }
-        }
-        // === LAZY REPAIR CHECK END ===
-        
-        std::cout << "FindNearestStorage for " << m_name << ": Found "
-                  << nearest->getBlueprintId() << " at dist " << minDist
-                  << " StorageID: [" << nearest->getStorageId() << "]" << std::endl;
-    } else {
-        std::cout << "FindNearestStorage for " << m_name << ": NONE FOUND" << std::endl;
-    }
-    
-    return nearest;
 }
 
-void Settler::UpdateHauling(float deltaTime, const std::vector<BuildingInstance*>& buildings, std::vector<WorldItem>& worldItems) {
-    (void)deltaTime;
-    (void)buildings;
-    (void)worldItems;
-    // Fallback simple hauling (picking up loose items)
-    // ... (Existing logic or simplified)
-    m_state = SettlerState::IDLE;
+InterruptCurrentAction();
+
+return;
+
 }
 
-void Settler::UpdateSleeping(float deltaTime) {
-    // Regenerate energy using EnergyComponent if available, otherwise fallback to StatsComponent
-    if (auto energyComp = getComponent<EnergyComponent>()) {
-        energyComp->currentEnergy += energyComp->rechargeRate * deltaTime;
-        if (energyComp->currentEnergy >= energyComp->maxEnergy) {
-             energyComp->currentEnergy = energyComp->maxEnergy;
-             m_state = SettlerState::IDLE;
-             
-             // Stop sleeping in bed
-             if (m_assignedBed) {
-                 if (auto bed = m_assignedBed->getBed()) {
-                     bed->stopSleeping();
-                 }
-             }
-
-             // Teleport outside house
-            if (m_assignedBed) {
-                if (auto door = m_assignedBed->getDoor()) {
-                    position = door->getPosition();
-                } else {
-                    position = Vector3Add(m_assignedBed->getPosition(), {2.0f, 0, 0});
-                }
-            }
-        }
-        // Sync with stats component for compatibility
-        m_stats.setEnergy(energyComp->currentEnergy);
-    } else {
-        // Legacy fallback
-        m_stats.modifyEnergy(20.0f * deltaTime);
-        if (m_stats.getCurrentEnergy() >= 99.0f) {
-            m_state = SettlerState::IDLE;
-             // Teleport outside house
-            if (m_assignedBed) {
-                if (auto door = m_assignedBed->getDoor()) {
-                    position = door->getPosition();
-                } else {
-                    position = Vector3Add(m_assignedBed->getPosition(), {2.0f, 0, 0});
-                }
-            }
-        }
-    }
+float woodAmount = m_currentTree->harvest(10.0f);
+
+(void)woodAmount;
+
+if (m_currentTree->isStump()) {
+
+auto woodItem = std::make_unique<ResourceItem>("Wood", "Wood Log", "Freshly chopped wood.");
+
+if (GameEngine::dropItemCallback) {
+
+Vector3 dropPos = m_currentTree->getPosition();
+
+dropPos.x += (float)(rand()%10 - 5) * 0.1f;
+
+dropPos.z += (float)(rand()%10 - 5) * 0.1f;
+
+dropPos.y = 0.5f;
+
+GameEngine::dropItemCallback(dropPos, woodItem.release());
+
 }
 
-// Housing
-void Settler::assignBed(BuildingInstance* bed) {
-    m_assignedBed = bed;
+m_currentTree->releaseReservation();
+
+m_state = SettlerState::IDLE;
+
+m_currentTree = nullptr;
+
 }
 
-Vector3 Settler::myHousePos() const {
-    if (m_assignedBed) return m_assignedBed->getPosition();
-    return {0,0,0};
 }
 
-// Inventory stubs
-bool Settler::PickupItem(Item* item) {
-    if (!item) return false;
-    auto clonedItem = item->clone();
-    if (!clonedItem) return false; // Safety check for clone
-    return m_inventory.addItem(std::move(clonedItem));
 }
+void Settler::UpdateMining(float deltaTime) {
+
+if (!m_currentResourceNode || !m_currentResourceNode->isActive()) {
+
+m_state = SettlerState::IDLE;
+
+return;
 
-void Settler::DropItem(int slotIndex) {
-    // This method currently drops 1 unit from the slot.
-    // In a full implementation, this would interact with the world/Colony to spawn a WorldItem entity.
-    // For now, it just removes from inventory, effectively "destroying" it unless hooked up elsewhere.
-    // The current codebase uses 'pendingDropItem' or direct Colony interaction for drops.
-    
-    const auto& items = m_inventory.getItems();
-    if (slotIndex >= 0 && slotIndex < (int)items.size() && items[slotIndex] && items[slotIndex]->item) {
-        // We need to extract the item to drop it
-        // m_inventory.dropItem deletes it.
-        // To drop into world, we'd need:
-        // auto itemToDrop = m_inventory.extractItem(slotIndex, 1); // If such method existed
-        // GameEngine::getInstance().dropItemCallback(position, itemToDrop.release());
-        
-        // For now, just remove from inventory as per existing logic
-        m_inventory.dropItem(slotIndex, 1);
-    }
 }
 
-// Food Logic
-Bush* Settler::FindNearestFood(const std::vector<Bush*>& bushes) {
-    Bush* nearest = nullptr;
-    float minDist = 1000.0f;
-    
-    for (auto* bush : bushes) {
-        if (bush && bush->hasFruit) {
-             float dist = Vector3Distance(position, bush->position);
-             if (dist < minDist) {
-                 minDist = dist;
-                 nearest = bush;
-             }
-        }
-    }
-    return nearest;
+if (m_pendingReevaluation) {
+
+if (m_currentResourceNode) {
+
+m_currentResourceNode->releaseReservation();
+
 }
 
-void Settler::UpdateSearchingForFood(float deltaTime, const std::vector<Bush*>& bushes) {
-    (void)deltaTime;
-    Bush* food = FindNearestFood(bushes);
-    if (food) {
-        m_targetFoodBush = food;
-        MoveTo(food->position);
-        // MoveTo sets state to MOVING, override it to keep context
-        m_state = SettlerState::MOVING_TO_FOOD;
-    } else {
-        // No food found!
-        // Maybe just wander or idle
-        // Log warning sparingly
-        // std::cout << "Settler " << m_name << " is hungry but found no food!" << std::endl;
-        m_state = SettlerState::IDLE;
-    }
+m_pendingReevaluation = false;
+
+InterruptCurrentAction();
+
+return;
+
 }
 
-void Settler::UpdateMovingToFood(float deltaTime) {
-    if (!m_targetFoodBush || !m_targetFoodBush->hasFruit) {
-        // Target invalid or food gone
-        m_state = SettlerState::SEARCHING_FOR_FOOD;
-        return;
-    }
-    
-    float dist = Vector3Distance(position, m_targetFoodBush->position);
-    if (dist < 1.5f) {
-        m_state = SettlerState::EATING;
-        m_eatingTimer = 0.0f;
-    } else {
-        // Continue moving logic (reusing UpdateMovement helper would be nice if we passed empty lists,
-        // but MoveTo sets path so we can just assume we follow it)
-        // UpdateMovement requires lists for avoidance but basic path following is embedded.
-        // Actually UpdateMovement contains the path following logic.
-        // We need to call it.
-        // We can pass empty vectors since we aren't gathering/building
-        UpdateMovement(deltaTime, {}, {});
-    }
+m_gatherTimer += deltaTime;
+
+if (m_gatherTimer >= 1.0f) {
+
+m_gatherTimer = 0.0f;
+
+if (CheckForJobFlagActivation()) {
+
+if (m_currentResourceNode) {
+
+m_currentResourceNode->releaseReservation();
+
+}
+
+InterruptCurrentAction();
+
+return;
+
+}
+
+float minedAmount = m_currentResourceNode->harvest(10.0f);
+
+(void)minedAmount;
+
+// Drop Stone item
+
+auto stoneItem = std::make_unique<ResourceItem>("Stone", "Stone Chunk", "Heavy stone chunk.");
+
+stoneItem->setMaxStackSize(1); // Set limit to 1
+
+if (GameEngine::dropItemCallback) {
+
+Vector3 dropPos = m_currentResourceNode->getPosition();
+
+dropPos.x += (float)(rand()%10 - 5) * 0.1f;
+
+dropPos.z += (float)(rand()%10 - 5) * 0.1f;
+
+dropPos.y = 0.5f;
+
+GameEngine::dropItemCallback(dropPos, stoneItem.release());
+
+}
+
+if (m_currentResourceNode->isDepleted()) {
+
+m_currentResourceNode->releaseReservation();
+
+m_state = SettlerState::IDLE;
+
+m_currentResourceNode = nullptr;
+
 }
 
-void Settler::UpdateEating(float deltaTime) {
-    m_eatingTimer += deltaTime;
-    
-    // Visual feedback?
-    
-    if (m_eatingTimer >= 2.0f) {
-        // Finished eating
-        if (m_targetFoodBush) {
-            m_targetFoodBush->hasFruit = false;
-            m_targetFoodBush->regrowthTimer = 0.0f;
-        }
-        
-        // Restore hunger
-        m_stats.setHunger(m_stats.getMaxHunger());
-        
-        m_state = SettlerState::IDLE;
-        m_targetFoodBush = nullptr;
-    }
 }
 
+}
 void Settler::UpdateMovingToBed(float deltaTime) {
-    if (!m_assignedBed) {
-        m_state = SettlerState::SLEEPING; // Just sleep where we are if bed assignment lost
-        return;
-    }
+// Jeśli mamy ścieżkę, poruszaj się po waypointach
+if (!m_currentPath.empty() && m_currentPathIndex < (int)m_currentPath.size()) {
+Vector3 waypoint = m_currentPath[m_currentPathIndex];
+Vector3 direction = Vector3Subtract(waypoint, position);
+float distance = Vector3Length(direction);
+if (distance < 0.3f) { // osiągnięto waypoint
+m_currentPathIndex++;
+if (m_currentPathIndex >= (int)m_currentPath.size()) {
+// dotarliśmy do końca ścieżki
+m_currentPath.clear();
+m_currentPathIndex = 0;
+// przejdź do celu końcowego (m_targetPosition) bezpośrednio
+// (poniższa logika sprawdzi odległość do m_targetPosition)
+} else {
+// przejdź do następnego waypointa
+return;
+}
+} else {
+direction = Vector3Normalize(direction);
+Vector3 movement = Vector3Scale(direction, m_moveSpeed * deltaTime);
+position = Vector3Add(position, movement);
+return;
+}
+}
+// Bez ścieżki lub po jej zakończeniu: ruch bezpośredni do celu
+Vector3 direction = Vector3Subtract(m_targetPosition, position);
+float distance = Vector3Length(direction);
+if (distance < 0.5f) {
+m_state = SettlerState::SLEEPING;
+m_isMovingToCriticalTarget = false;
+return;
+}
+direction = Vector3Normalize(direction);
+Vector3 movement = Vector3Scale(direction, m_moveSpeed * deltaTime);
+position = Vector3Add(position, movement);
+}
+void Settler::CraftTool(const std::string& toolName) {
+
+(void)toolName;
+
+}
+bool Settler::PickupItem(Item* item) {
+
+(void)item;
+
+return false;
+
+}
+void Settler::DropItem(int slotIndex) {
+
+(void)slotIndex;
+
+}
+void Settler::ignoreStorage(const std::string& storageId) {
+
+m_ignoredStorages.push_back(storageId);
+
+}
+bool Settler::isStorageIgnored(const std::string& storageId) const {
+
+for (const auto& id : m_ignoredStorages) {
+
+if (id == storageId) return true;
+
+}
+
+return false;
+
+}
+void Settler::ClearIgnoredStorages() {
+
+m_ignoredStorages.clear();
+
+}
+Vector3 Settler::myHousePos() const {
+
+return {0,0,0};
+
+}
+bool Settler::IsStateInterruptible() const {
+
+switch (m_state) {
+
+case SettlerState::IDLE:
+
+case SettlerState::WANDER:
+
+case SettlerState::WAITING:
+
+return true;
+
+case SettlerState::MOVING:
+
+return !m_isMovingToCriticalTarget;
+
+case SettlerState::EATING:
+
+case SettlerState::SLEEPING:
+
+case SettlerState::SEARCHING_FOR_FOOD:
+
+case SettlerState::MOVING_TO_FOOD:
+
+case SettlerState::MOVING_TO_BED:
+
+case SettlerState::CHOPPING:
+
+case SettlerState::BUILDING:
+
+case SettlerState::DEPOSITING:
+
+case SettlerState::CRAFTING:
+
+case SettlerState::GATHERING:
+
+case SettlerState::MINING:
+
+case SettlerState::HAULING:
+
+case SettlerState::PICKING_UP:
+
+case SettlerState::HUNTING:
+
+case SettlerState::MOVING_TO_STORAGE:
+
+default:
+
+return false;
+
+}
+
+}
+bool Settler::CheckForJobFlagActivation() {
+
+bool flagJustActivated = false;
+
+if (gatherWood && !m_prevGatherWood) flagJustActivated = true;
+
+if (gatherStone && !m_prevGatherStone) flagJustActivated = true;
+
+if (gatherFood && !m_prevGatherFood) flagJustActivated = true;
+
+if (performBuilding && !m_prevPerformBuilding) flagJustActivated = true;
+
+if (huntAnimals && !m_prevHuntAnimals) flagJustActivated = true;
+
+if (craftItems && !m_prevCraftItems) flagJustActivated = true;
+
+if (haulToStorage && !m_prevHaulToStorage) flagJustActivated = true;
+
+if (tendCrops && !m_prevTendCrops) flagJustActivated = true;
+
+m_prevGatherWood = gatherWood;
+m_prevGatherStone = gatherStone;
+m_prevGatherFood = gatherFood;
+m_prevPerformBuilding = performBuilding;
+m_prevHuntAnimals = huntAnimals;
+m_prevCraftItems = craftItems;
+m_prevHaulToStorage = haulToStorage;
+m_prevTendCrops = tendCrops;
+
+return flagJustActivated;
+
+
+}
+void Settler::InterruptCurrentAction() {
+
+m_actionQueue.clear();
+
+m_currentPath.clear();
+
+m_currentPathIndex = 0;
+
+m_currentTree = nullptr;
+
+m_currentGatherBush = nullptr;
+
+m_targetStorage = nullptr;
+
+m_targetFoodBush = nullptr;
+
+m_gatherTimer = 0.0f;
+
+m_isMovingToCriticalTarget = false;
+
+m_pendingReevaluation = false;
+
+m_state = SettlerState::IDLE;
+
+}
+void Settler::OnJobConfigurationChanged() {
+
+m_prevGatherWood = gatherWood;
+
+m_prevGatherStone = gatherStone;
+
+m_prevGatherFood = gatherFood;
+
+m_prevPerformBuilding = performBuilding;
+
+m_prevHuntAnimals = huntAnimals;
+
+m_prevCraftItems = craftItems;
+
+m_prevHaulToStorage = haulToStorage;
+
+m_prevTendCrops = tendCrops;
+
+bool isSurvivalState = (m_state == SettlerState::EATING) ||
+                       (m_state == SettlerState::SLEEPING) ||
+                       (m_state == SettlerState::MOVING_TO_BED) ||
+                       (m_state == SettlerState::MOVING_TO_FOOD);
+
+if (isSurvivalState) {
+    m_pendingReevaluation = true;
+    return;
+}
+
+if (m_state == SettlerState::CHOPPING && m_currentTree) {
+    m_currentTree->releaseReservation();
+}
+
+InterruptCurrentAction();
+
+
+}
+void Settler::UpdateHauling(float deltaTime, const std::vector<BuildingInstance*>& buildings, std::vector<WorldItem>& worldItems) {
+
+(void)deltaTime;
+
+(void)buildings;
+
+float minDist = 100.0f;
+
+WorldItem* targetItem = nullptr;
+
+for (auto& item : worldItems) {
+
+if (item.pendingRemoval) continue;
+
+if (!item.item) continue;
+
+if (item.item->getItemType() == ItemType::RESOURCE) {
+
+float d = Vector3Distance(position, item.position);
+
+if (d < minDist) {
+
+minDist = d;
+
+targetItem = &item;
+
+}
+
+}
+
+}
+
+if (targetItem) {
+
+MoveTo(targetItem->position);
+
+m_state = SettlerState::PICKING_UP;
+
+}
 
-    float dist = Vector3Distance(position, m_assignedBed->getPosition());
-    if (dist < 2.0f) {
-        m_state = SettlerState::SLEEPING;
-        // Align position with bed/sleeping spot visually if needed
-        if (auto bed = m_assignedBed->getBed()) {
-            bed->startSleeping(this);
-             // Optional: snap position to bed center
-             position = m_assignedBed->getPosition();
-        }
-    } else {
-        UpdateMovement(deltaTime, {}, {});
-    }
 }
